<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>struct/commands/arguments/Argument.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AkairoClient.html">AkairoClient</a><ul class='methods'><li data-type='method' style='display: none;'><a href="AkairoClient.html#isOwner">isOwner</a></li></ul></li><li><a href="AkairoError.html">AkairoError</a></li><li><a href="AkairoHandler.html">AkairoHandler</a><ul class='methods'><li data-type='method' style='display: none;'><a href="AkairoHandler.html#.readdirRecursive">(static) readdirRecursive</a></li><li data-type='method' style='display: none;'><a href="AkairoHandler.html#deregister">deregister</a></li><li data-type='method' style='display: none;'><a href="AkairoHandler.html#findCategory">findCategory</a></li><li data-type='method' style='display: none;'><a href="AkairoHandler.html#load">load</a></li><li data-type='method' style='display: none;'><a href="AkairoHandler.html#loadAll">loadAll</a></li><li data-type='method' style='display: none;'><a href="AkairoHandler.html#register">register</a></li><li data-type='method' style='display: none;'><a href="AkairoHandler.html#reload">reload</a></li><li data-type='method' style='display: none;'><a href="AkairoHandler.html#reloadAll">reloadAll</a></li><li data-type='method' style='display: none;'><a href="AkairoHandler.html#remove">remove</a></li><li data-type='method' style='display: none;'><a href="AkairoHandler.html#removeAll">removeAll</a></li></ul><ul class='methods'><li data-type='method' style='display: none;'><a href="AkairoHandler.html#event:load">(event) load</a></li><li data-type='method' style='display: none;'><a href="AkairoHandler.html#event:remove">(event) remove</a></li></ul></li><li><a href="AkairoModule.html">AkairoModule</a><ul class='methods'><li data-type='method' style='display: none;'><a href="AkairoModule.html#reload">reload</a></li><li data-type='method' style='display: none;'><a href="AkairoModule.html#remove">remove</a></li><li data-type='method' style='display: none;'><a href="AkairoModule.html#toString">toString</a></li></ul></li><li><a href="Argument.html">Argument</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Argument.html#.cast">(static) cast</a></li><li data-type='method' style='display: none;'><a href="Argument.html#.compose">(static) compose</a></li><li data-type='method' style='display: none;'><a href="Argument.html#.map">(static) map</a></li><li data-type='method' style='display: none;'><a href="Argument.html#.range">(static) range</a></li><li data-type='method' style='display: none;'><a href="Argument.html#.tuple">(static) tuple</a></li><li data-type='method' style='display: none;'><a href="Argument.html#.union">(static) union</a></li><li data-type='method' style='display: none;'><a href="Argument.html#.validate">(static) validate</a></li><li data-type='method' style='display: none;'><a href="Argument.html#cast">cast</a></li><li data-type='method' style='display: none;'><a href="Argument.html#collect">collect</a></li><li data-type='method' style='display: none;'><a href="Argument.html#process">process</a></li></ul></li><li><a href="ArgumentParser.html">ArgumentParser</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ArgumentParser.html#.getFlags">(static) getFlags</a></li><li data-type='method' style='display: none;'><a href="ArgumentParser.html#buildArgs">buildArgs</a></li><li data-type='method' style='display: none;'><a href="ArgumentParser.html#parse">parse</a></li></ul></li><li><a href="CancelControl.html">CancelControl</a><ul class='methods'><li data-type='method' style='display: none;'><a href="CancelControl.html#control">control</a></li><li data-type='method' style='display: none;'><a href="CancelControl.html#getArgs">getArgs</a></li></ul></li><li><a href="CaseControl.html">CaseControl</a><ul class='methods'><li data-type='method' style='display: none;'><a href="CaseControl.html#control">control</a></li><li data-type='method' style='display: none;'><a href="CaseControl.html#getArgs">getArgs</a></li></ul></li><li><a href="Category.html">Category</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Category.html#reloadAll">reloadAll</a></li><li data-type='method' style='display: none;'><a href="Category.html#removeAll">removeAll</a></li><li data-type='method' style='display: none;'><a href="Category.html#toString">toString</a></li></ul></li><li><a href="ClientUtil.html">ClientUtil</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ClientUtil.html#attachment">attachment</a></li><li data-type='method' style='display: none;'><a href="ClientUtil.html#checkChannel">checkChannel</a></li><li data-type='method' style='display: none;'><a href="ClientUtil.html#checkEmoji">checkEmoji</a></li><li data-type='method' style='display: none;'><a href="ClientUtil.html#checkGuild">checkGuild</a></li><li data-type='method' style='display: none;'><a href="ClientUtil.html#checkMember">checkMember</a></li><li data-type='method' style='display: none;'><a href="ClientUtil.html#checkRole">checkRole</a></li><li data-type='method' style='display: none;'><a href="ClientUtil.html#checkUser">checkUser</a></li><li data-type='method' style='display: none;'><a href="ClientUtil.html#collection">collection</a></li><li data-type='method' style='display: none;'><a href="ClientUtil.html#compareStreaming">compareStreaming</a></li><li data-type='method' style='display: none;'><a href="ClientUtil.html#embed">embed</a></li><li data-type='method' style='display: none;'><a href="ClientUtil.html#fetchMember">fetchMember</a></li><li data-type='method' style='display: none;'><a href="ClientUtil.html#permissionNames">permissionNames</a></li><li data-type='method' style='display: none;'><a href="ClientUtil.html#resolveChannel">resolveChannel</a></li><li data-type='method' style='display: none;'><a href="ClientUtil.html#resolveChannels">resolveChannels</a></li><li data-type='method' style='display: none;'><a href="ClientUtil.html#resolveEmoji">resolveEmoji</a></li><li data-type='method' style='display: none;'><a href="ClientUtil.html#resolveEmojis">resolveEmojis</a></li><li data-type='method' style='display: none;'><a href="ClientUtil.html#resolveGuild">resolveGuild</a></li><li data-type='method' style='display: none;'><a href="ClientUtil.html#resolveGuilds">resolveGuilds</a></li><li data-type='method' style='display: none;'><a href="ClientUtil.html#resolveMember">resolveMember</a></li><li data-type='method' style='display: none;'><a href="ClientUtil.html#resolveMembers">resolveMembers</a></li><li data-type='method' style='display: none;'><a href="ClientUtil.html#resolvePermissionNumber">resolvePermissionNumber</a></li><li data-type='method' style='display: none;'><a href="ClientUtil.html#resolveRole">resolveRole</a></li><li data-type='method' style='display: none;'><a href="ClientUtil.html#resolveRoles">resolveRoles</a></li><li data-type='method' style='display: none;'><a href="ClientUtil.html#resolveUser">resolveUser</a></li><li data-type='method' style='display: none;'><a href="ClientUtil.html#resolveUsers">resolveUsers</a></li></ul></li><li><a href="Command.html">Command</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Command.html#before">before</a></li><li data-type='method' style='display: none;'><a href="Command.html#condition">condition</a></li><li data-type='method' style='display: none;'><a href="Command.html#exec">exec</a></li><li data-type='method' style='display: none;'><a href="Command.html#parse">parse</a></li><li data-type='method' style='display: none;'><a href="Command.html#reload">reload</a></li><li data-type='method' style='display: none;'><a href="Command.html#remove">remove</a></li><li data-type='method' style='display: none;'><a href="Command.html#toString">toString</a></li></ul></li><li><a href="CommandCancel.html">CommandCancel</a></li><li><a href="CommandHandler.html">CommandHandler</a><ul class='methods'><li data-type='method' style='display: none;'><a href="CommandHandler.html#addPrompt">addPrompt</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#deregister">deregister</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#emitError">emitError</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#findCategory">findCategory</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#findCommand">findCommand</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#handle">handle</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#handleConditionalCommands">handleConditionalCommands</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#handleDirectCommand">handleDirectCommand</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#handleRegexAndConditionalCommands">handleRegexAndConditionalCommands</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#handleRegexCommands">handleRegexCommands</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#hasPrompt">hasPrompt</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#load">load</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#loadAll">loadAll</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#parseCommand">parseCommand</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#parseCommandWithOverwrittenPrefixes">parseCommandWithOverwrittenPrefixes</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#register">register</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#reload">reload</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#reloadAll">reloadAll</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#remove">remove</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#removeAll">removeAll</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#removePrompt">removePrompt</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#runAllTypeInhibitors">runAllTypeInhibitors</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#runCommand">runCommand</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#runCooldowns">runCooldowns</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#runPermissionChecks">runPermissionChecks</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#runPostTypeInhibitors">runPostTypeInhibitors</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#runPreTypeInhibitors">runPreTypeInhibitors</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#useInhibitorHandler">useInhibitorHandler</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#useListenerHandler">useListenerHandler</a></li></ul><ul class='methods'><li data-type='method' style='display: none;'><a href="CommandHandler.html#event:commandBlocked">(event) commandBlocked</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#event:commandCancelled">(event) commandCancelled</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#event:commandDisabled">(event) commandDisabled</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#event:commandFinished">(event) commandFinished</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#event:commandStarted">(event) commandStarted</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#event:cooldown">(event) cooldown</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#event:error">(event) error</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#event:inPrompt">(event) inPrompt</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#event:load">(event) load</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#event:messageBlocked">(event) messageBlocked</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#event:messageInvalid">(event) messageInvalid</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#event:missingPermissions">(event) missingPermissions</a></li><li data-type='method' style='display: none;'><a href="CommandHandler.html#event:remove">(event) remove</a></li></ul></li><li><a href="CommandRetry.html">CommandRetry</a></li><li><a href="CommandUtil.html">CommandUtil</a><ul class='methods'><li data-type='method' style='display: none;'><a href="CommandUtil.html#.swapOptions">(static) swapOptions</a></li><li data-type='method' style='display: none;'><a href="CommandUtil.html#addMessage">addMessage</a></li><li data-type='method' style='display: none;'><a href="CommandUtil.html#edit">edit</a></li><li data-type='method' style='display: none;'><a href="CommandUtil.html#reply">reply</a></li><li data-type='method' style='display: none;'><a href="CommandUtil.html#send">send</a></li><li data-type='method' style='display: none;'><a href="CommandUtil.html#sendNew">sendNew</a></li><li data-type='method' style='display: none;'><a href="CommandUtil.html#setEditable">setEditable</a></li><li data-type='method' style='display: none;'><a href="CommandUtil.html#setLastResponse">setLastResponse</a></li></ul></li><li><a href="ContentParser.html">ContentParser</a></li><li><a href="ContentParserState.html">ContentParserState</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ContentParserState.html#check">check</a></li><li data-type='method' style='display: none;'><a href="ContentParserState.html#createToken">createToken</a></li><li data-type='method' style='display: none;'><a href="ContentParserState.html#match">match</a></li><li data-type='method' style='display: none;'><a href="ContentParserState.html#next">next</a></li><li data-type='method' style='display: none;'><a href="ContentParserState.html#parse">parse</a></li><li data-type='method' style='display: none;'><a href="ContentParserState.html#parseArgument">parseArgument</a></li><li data-type='method' style='display: none;'><a href="ContentParserState.html#parseFlag">parseFlag</a></li><li data-type='method' style='display: none;'><a href="ContentParserState.html#parsePhrase">parsePhrase</a></li><li data-type='method' style='display: none;'><a href="ContentParserState.html#tokenize">tokenize</a></li></ul></li><li><a href="Control.html">Control</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Control.html#.cancel">(static) cancel</a></li><li data-type='method' style='display: none;'><a href="Control.html#.case">(static) case</a></li><li data-type='method' style='display: none;'><a href="Control.html#.do">(static) do</a></li><li data-type='method' style='display: none;'><a href="Control.html#.end">(static) end</a></li><li data-type='method' style='display: none;'><a href="Control.html#.if">(static) if</a></li><li data-type='method' style='display: none;'><a href="Control.html#control">control</a></li><li data-type='method' style='display: none;'><a href="Control.html#getArgs">getArgs</a></li></ul></li><li><a href="DoControl.html">DoControl</a><ul class='methods'><li data-type='method' style='display: none;'><a href="DoControl.html#control">control</a></li><li data-type='method' style='display: none;'><a href="DoControl.html#getArgs">getArgs</a></li></ul></li><li><a href="EndControl.html">EndControl</a><ul class='methods'><li data-type='method' style='display: none;'><a href="EndControl.html#control">control</a></li><li data-type='method' style='display: none;'><a href="EndControl.html#getArgs">getArgs</a></li></ul></li><li><a href="IfControl.html">IfControl</a><ul class='methods'><li data-type='method' style='display: none;'><a href="IfControl.html#control">control</a></li><li data-type='method' style='display: none;'><a href="IfControl.html#getArgs">getArgs</a></li></ul></li><li><a href="Inhibitor.html">Inhibitor</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Inhibitor.html#exec">exec</a></li><li data-type='method' style='display: none;'><a href="Inhibitor.html#reload">reload</a></li><li data-type='method' style='display: none;'><a href="Inhibitor.html#remove">remove</a></li><li data-type='method' style='display: none;'><a href="Inhibitor.html#toString">toString</a></li></ul></li><li><a href="InhibitorHandler.html">InhibitorHandler</a><ul class='methods'><li data-type='method' style='display: none;'><a href="InhibitorHandler.html#deregister">deregister</a></li><li data-type='method' style='display: none;'><a href="InhibitorHandler.html#findCategory">findCategory</a></li><li data-type='method' style='display: none;'><a href="InhibitorHandler.html#load">load</a></li><li data-type='method' style='display: none;'><a href="InhibitorHandler.html#loadAll">loadAll</a></li><li data-type='method' style='display: none;'><a href="InhibitorHandler.html#register">register</a></li><li data-type='method' style='display: none;'><a href="InhibitorHandler.html#reload">reload</a></li><li data-type='method' style='display: none;'><a href="InhibitorHandler.html#reloadAll">reloadAll</a></li><li data-type='method' style='display: none;'><a href="InhibitorHandler.html#remove">remove</a></li><li data-type='method' style='display: none;'><a href="InhibitorHandler.html#removeAll">removeAll</a></li><li data-type='method' style='display: none;'><a href="InhibitorHandler.html#test">test</a></li></ul><ul class='methods'><li data-type='method' style='display: none;'><a href="InhibitorHandler.html#event:load">(event) load</a></li><li data-type='method' style='display: none;'><a href="InhibitorHandler.html#event:remove">(event) remove</a></li></ul></li><li><a href="Listener.html">Listener</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Listener.html#exec">exec</a></li><li data-type='method' style='display: none;'><a href="Listener.html#reload">reload</a></li><li data-type='method' style='display: none;'><a href="Listener.html#remove">remove</a></li><li data-type='method' style='display: none;'><a href="Listener.html#toString">toString</a></li></ul></li><li><a href="ListenerHandler.html">ListenerHandler</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ListenerHandler.html#addToEmitter">addToEmitter</a></li><li data-type='method' style='display: none;'><a href="ListenerHandler.html#deregister">deregister</a></li><li data-type='method' style='display: none;'><a href="ListenerHandler.html#findCategory">findCategory</a></li><li data-type='method' style='display: none;'><a href="ListenerHandler.html#load">load</a></li><li data-type='method' style='display: none;'><a href="ListenerHandler.html#loadAll">loadAll</a></li><li data-type='method' style='display: none;'><a href="ListenerHandler.html#register">register</a></li><li data-type='method' style='display: none;'><a href="ListenerHandler.html#reload">reload</a></li><li data-type='method' style='display: none;'><a href="ListenerHandler.html#reloadAll">reloadAll</a></li><li data-type='method' style='display: none;'><a href="ListenerHandler.html#remove">remove</a></li><li data-type='method' style='display: none;'><a href="ListenerHandler.html#removeAll">removeAll</a></li><li data-type='method' style='display: none;'><a href="ListenerHandler.html#removeFromEmitter">removeFromEmitter</a></li><li data-type='method' style='display: none;'><a href="ListenerHandler.html#setEmitters">setEmitters</a></li></ul><ul class='methods'><li data-type='method' style='display: none;'><a href="ListenerHandler.html#event:load">(event) load</a></li><li data-type='method' style='display: none;'><a href="ListenerHandler.html#event:remove">(event) remove</a></li></ul></li><li><a href="ParsingFlag.html">ParsingFlag</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ParsingFlag.html#.cancel">(static) cancel</a></li><li data-type='method' style='display: none;'><a href="ParsingFlag.html#.retry">(static) retry</a></li></ul></li><li><a href="Provider.html">Provider</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Provider.html#clear">clear</a></li><li data-type='method' style='display: none;'><a href="Provider.html#delete">delete</a></li><li data-type='method' style='display: none;'><a href="Provider.html#get">get</a></li><li data-type='method' style='display: none;'><a href="Provider.html#init">init</a></li><li data-type='method' style='display: none;'><a href="Provider.html#set">set</a></li></ul></li><li><a href="SequelizeProvider.html">SequelizeProvider</a><ul class='methods'><li data-type='method' style='display: none;'><a href="SequelizeProvider.html#clear">clear</a></li><li data-type='method' style='display: none;'><a href="SequelizeProvider.html#delete">delete</a></li><li data-type='method' style='display: none;'><a href="SequelizeProvider.html#get">get</a></li><li data-type='method' style='display: none;'><a href="SequelizeProvider.html#init">init</a></li><li data-type='method' style='display: none;'><a href="SequelizeProvider.html#set">set</a></li></ul></li><li><a href="SQLiteProvider.html">SQLiteProvider</a><ul class='methods'><li data-type='method' style='display: none;'><a href="SQLiteProvider.html#clear">clear</a></li><li data-type='method' style='display: none;'><a href="SQLiteProvider.html#delete">delete</a></li><li data-type='method' style='display: none;'><a href="SQLiteProvider.html#get">get</a></li><li data-type='method' style='display: none;'><a href="SQLiteProvider.html#init">init</a></li><li data-type='method' style='display: none;'><a href="SQLiteProvider.html#set">set</a></li></ul></li><li><a href="TypeResolver.html">TypeResolver</a><ul class='methods'><li data-type='method' style='display: none;'><a href="TypeResolver.html#addBuiltInTypes">addBuiltInTypes</a></li><li data-type='method' style='display: none;'><a href="TypeResolver.html#addType">addType</a></li><li data-type='method' style='display: none;'><a href="TypeResolver.html#addTypes">addTypes</a></li><li data-type='method' style='display: none;'><a href="TypeResolver.html#type">type</a></li></ul></li></ul><h3>Typedefs</h3><ul><li><a href="global.html#AkairoHandlerOptions">AkairoHandlerOptions</a></li><li><a href="global.html#AkairoModuleOptions">AkairoModuleOptions</a></li><li><a href="global.html#AkairoOptions">AkairoOptions</a></li><li><a href="global.html#ArgumentMatch">ArgumentMatch</a></li><li><a href="global.html#ArgumentOptions">ArgumentOptions</a></li><li><a href="global.html#ArgumentPromptData">ArgumentPromptData</a></li><li><a href="global.html#ArgumentPromptOptions">ArgumentPromptOptions</a></li><li><a href="global.html#ArgumentProvider">ArgumentProvider</a></li><li><a href="global.html#ArgumentType">ArgumentType</a></li><li><a href="global.html#ArgumentTypeCaster">ArgumentTypeCaster</a></li><li><a href="global.html#BeforeAction">BeforeAction</a></li><li><a href="global.html#CommandHandlerOptions">CommandHandlerOptions</a></li><li><a href="global.html#CommandOptions">CommandOptions</a></li><li><a href="global.html#ContentParserOptions">ContentParserOptions</a></li><li><a href="global.html#ControlAction">ControlAction</a></li><li><a href="global.html#ControlPredicate">ControlPredicate</a></li><li><a href="global.html#DefaultValueSupplier">DefaultValueSupplier</a></li><li><a href="global.html#ExecutionPredicate">ExecutionPredicate</a></li><li><a href="global.html#IgnoreCheckPredicate">IgnoreCheckPredicate</a></li><li><a href="global.html#InhibitorOptions">InhibitorOptions</a></li><li><a href="global.html#ListenerOptions">ListenerOptions</a></li><li><a href="global.html#LoadPredicate">LoadPredicate</a></li><li><a href="global.html#MentionPrefixPredicate">MentionPrefixPredicate</a></li><li><a href="global.html#MessageExtensions">MessageExtensions</a></li><li><a href="global.html#MissingPermissionSupplier">MissingPermissionSupplier</a></li><li><a href="global.html#ParsedComponentData">ParsedComponentData</a></li><li><a href="global.html#ParsedValueMapper">ParsedValueMapper</a></li><li><a href="global.html#ParsedValuePredicate">ParsedValuePredicate</a></li><li><a href="global.html#PrefixSupplier">PrefixSupplier</a></li><li><a href="global.html#PromptContentModifier">PromptContentModifier</a></li><li><a href="global.html#PromptContentSupplier">PromptContentSupplier</a></li><li><a href="global.html#ProviderOptions">ProviderOptions</a></li><li><a href="global.html#RegexSupplier">RegexSupplier</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">struct/commands/arguments/Argument.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const { ArgumentMatches, ArgumentTypes } = require('../../../util/Constants');
const ParsingFlag = require('../ParsingFlag');
const { isPromise } = require('../../../util/Util');

class Argument {
    /**
     * An argument for a command.
     * @param {Command} command - Command of the argument.
     * @param {ArgumentOptions} options - Options for the argument.
     */
    constructor(command, {
        id,
        match = ArgumentMatches.PHRASE,
        type = ArgumentTypes.STRING,
        flag = null,
        index = null,
        unordered = false,
        limit = Infinity,
        description = '',
        prompt = null,
        default: defaultValue = null
    } = {}) {
        /**
         * The ID of the argument.
         * @type {string}
         */
        this.id = id;

        /**
         * The command this argument belongs to.
         * @type {Command}
         */
        this.command = command;

        /**
         * The method to match text.
         * @type {ArgumentMatch}
         */
        this.match = match;

        /**
         * The type to cast to or a function to use to cast.
         * @type {ArgumentType|ArgumentTypeCaster}
         */
        this.type = typeof type === 'function' ? type.bind(this) : type;

        /**
         * The string(s) to use for flag or option match.
         * @type {?string|string[]}
         */
        this.flag = flag;

        /**
         * The index to start from.
         * @type {?number}
         */
        this.index = index;

        /**
         * Whether or not the argument is unordered.
         * @type {boolean|number|number[]}
         */
        this.unordered = unordered;

        /**
         * The amount of phrases to match for rest, separate, content, or text match.
         * @type {number}
         */
        this.limit = limit;

        /**
         * The description of the argument.
         * @type {string}
         */
        this.description = Array.isArray(description) ? description.join('\n') : description;

        /**
         * The prompt options.
         * @type {?ArgumentPromptOptions}
         */
        this.prompt = prompt;

        /**
         * The default value of the argument or a function supplying the default value.
         * @type {any|DefaultValueSupplier}
         */
        this.default = typeof defaultValue === 'function' ? defaultValue.bind(this) : defaultValue;
    }

    /**
     * The client.
     * @type {AkairoClient}
     */
    get client() {
        return this.command.client;
    }

    /**
     * The command handler.
     * @type {CommandHandler}
     */
    get handler() {
        return this.command.handler;
    }

    /**
     * Processes the type casting and prompting of the argument for a phrase.
     * @param {string} phrase - The phrase to process.
     * @param {Message} message - The message that called the command.
     * @param {Object} args - Previous arguments from command.
     * @returns {Promise&lt;any>}
     */
    async process(phrase, message, args = {}) {
        phrase = phrase.trim();

        const isOptional = (this.prompt &amp;&amp; this.prompt.optional)
            || (this.command.defaultPrompt &amp;&amp; this.command.defaultPrompt.optional)
            || (this.handler.defaultPrompt &amp;&amp; this.handler.defaultPrompt.optional);

        if (!phrase &amp;&amp; isOptional) {
            let res = typeof this.default === 'function' ? this.default(message, args) : this.default;
            if (isPromise(res)) res = await res;
            return res;
        }

        let res = await this.cast(phrase, message, args);

        if (res == null) {
            if (this.prompt) return this.collect(message, args, phrase);

            res = typeof this.default === 'function' ? this.default(message, args) : this.default;
            if (isPromise(res)) res = await res;
            return res;
        }

        return res;
    }

    /**
     * Casts a phrase to this argument's type.
     * @param {string} phrase - Phrase to process.
     * @param {Message} message - Message that called the command.
     * @param {Object} args - Previous arguments from command.
     * @returns {Promise&lt;any>}
     */
    cast(phrase, message, args = {}) {
        return Argument.cast(this.type, this.handler.resolver, phrase, message, args);
    }

    /**
     * Collects input from the user by prompting.
     * @param {Message} message - Message to prompt.
     * @param {Object} args - Previous arguments from command.
     * @param {string} [commandInput] - Previous input from command if there was one.
     * @returns {Promise&lt;any|ParsingFlag>}
     */
    async collect(message, args = {}, commandInput = '') {
        const promptOptions = {};

        Object.assign(promptOptions, this.handler.defaultPrompt);
        Object.assign(promptOptions, this.command.defaultPrompt);
        Object.assign(promptOptions, this.prompt || {});

        const isInfinite = promptOptions.infinite &amp;&amp; (this.match === ArgumentMatches.SEPARATE ? !commandInput : true);
        const additionalRetry = Number(Boolean(commandInput));

        const values = isInfinite ? [] : null;
        if (isInfinite) args[this.id] = values;

        const getText = (promptType, prompter, retryCount, inputMessage, inputPhrase) => {
            let text = prompter;

            if (typeof prompter === 'function') {
                text = prompter.call(this, message, args, {
                    retries: retryCount,
                    infinite: isInfinite,
                    message: inputMessage,
                    phrase: inputPhrase
                });
            }

            if (Array.isArray(text)) {
                text = text.join('\n');
            }

            const modifier = {
                start: promptOptions.modifyStart,
                retry: promptOptions.modifyRetry,
                timeout: promptOptions.modifyTimeout,
                ended: promptOptions.modifyEnded,
                cancel: promptOptions.modifyCancel
            }[promptType];

            if (modifier) {
                text = modifier.call(this, text, message, args, {
                    retries: retryCount,
                    infinite: isInfinite,
                    message: inputMessage,
                    phrase: inputPhrase
                });
            }

            if (Array.isArray(text)) {
                text = text.join('\n');
            }

            return text;
        };

        // eslint-disable-next-line complexity
        const promptOne = async (prevMessage, retryCount) => {
            let sentStart;
            const shouldSend = retryCount === 1
                ? !isInfinite || (isInfinite &amp;&amp; !values.length)
                : true;

            if (shouldSend) {
                let prevInput;
                if (retryCount &lt;= 1 + additionalRetry) {
                    prevInput = commandInput || '';
                } else {
                    prevInput = prevMessage.content;
                }

                const promptType = retryCount === 1 ? 'start' : 'retry';
                const prompter = retryCount === 1 ? promptOptions.start : promptOptions.retry;
                const startText = getText(promptType, prompter, retryCount, prevMessage, prevInput);

                if (startText) {
                    sentStart = await (message.util || message.channel).send(startText);
                    if (message.util) {
                        message.util.setEditable(false);
                        message.util.setLastResponse(sentStart);
                        message.util.addMessage(sentStart);
                    }
                }
            }

            let input;
            try {
                input = (await message.channel.awaitMessages(m => {
                    if (sentStart &amp;&amp; m.id === sentStart.id) return false;
                    if (m.author.id !== message.author.id) return false;
                    return true;
                }, {
                    max: 1,
                    time: promptOptions.time,
                    errors: ['time']
                })).first();

                if (message.util) message.util.addMessage(input);
            } catch (err) {
                const timeoutText = getText('timeout', promptOptions.timeout, retryCount, prevMessage, '');
                if (timeoutText) {
                    const sentTimeout = await message.channel.send(timeoutText);
                    if (message.util) message.util.addMessage(sentTimeout);
                }

                return ParsingFlag.cancel();
            }

            if (promptOptions.breakout) {
                const looksLike = await this.handler.parseCommand(input);
                if (looksLike &amp;&amp; looksLike.command) return ParsingFlag.retry(input);
            }

            if (input.content.toLowerCase() === promptOptions.cancelWord.toLowerCase()) {
                const cancelText = getText('cancel', promptOptions.cancel, retryCount, input, '');
                if (cancelText) {
                    const sentCancel = await message.channel.send(cancelText);
                    if (message.util) message.util.addMessage(sentCancel);
                }

                return ParsingFlag.cancel();
            }

            if (isInfinite &amp;&amp; input.content.toLowerCase() === promptOptions.stopWord.toLowerCase()) {
                if (!values.length) return promptOne(input, retryCount + 1);
                return values;
            }

            const parsedValue = await this.cast(input.content, input, args);
            if (parsedValue == null) {
                if (retryCount &lt;= promptOptions.retries) {
                    return promptOne(input, retryCount + 1);
                }

                const endedText = getText('ended', promptOptions.ended, retryCount, input, input.content);
                if (endedText) {
                    const sentEnded = await message.channel.send(endedText);
                    if (message.util) message.util.addMessage(sentEnded);
                }

                return ParsingFlag.cancel();
            }

            if (isInfinite) {
                values.push(parsedValue);
                const limit = promptOptions.limit;
                if (values.length &lt; limit) return promptOne(message, 1);

                return values;
            }

            return parsedValue;
        };

        this.handler.addPrompt(message.channel, message.author);
        const returnValue = await promptOne(message, 1 + additionalRetry);
        if (this.handler.commandUtil) message.util.setEditable(false);
        this.handler.removePrompt(message.channel, message.author);
        return returnValue;
    }

    /**
     * Casts a phrase to the specified type.
     * @param {ArgumentType|ArgumentTypeCaster} type - Type to use.
     * @param {TypeResolver} resolver - Type resolver to use.
     * @param {string} phrase - Phrase to process.
     * @param {Message} message - Message that called the command.
     * @param {Object} args - Previous arguments from command.
     * @returns {Promise&lt;any>}
     */
    static async cast(type, resolver, phrase, message, args) {
        if (Array.isArray(type)) {
            for (const entry of type) {
                if (Array.isArray(entry)) {
                    if (entry.some(t => t.toLowerCase() === phrase.toLowerCase())) {
                        return entry[0];
                    }
                } else if (entry.toLowerCase() === phrase.toLowerCase()) {
                    return entry;
                }
            }

            return null;
        }

        if (typeof type === 'function') {
            let res = type(phrase, message, args);
            if (isPromise(res)) res = await res;
            if (res != null) return res;
            return null;
        }

        if (type instanceof RegExp) {
            const match = phrase.match(type);
            if (!match) return null;

            const matches = [];

            if (type.global) {
                let matched;

                while ((matched = type.exec(phrase)) != null) {
                    matches.push(matched);
                }
            }

            return { match, matches };
        }

        if (resolver.type(type)) {
            let res = resolver.type(type).call(this, phrase, message, args);
            if (isPromise(res)) res = await res;
            if (res != null) return res;
            return null;
        }

        if (phrase) return phrase;
        return null;
    }

    /* eslint-disable no-invalid-this */
    /**
     * Creates a type from multiple types (union type).
     * The first type that resolves to a non-void value is used.
     * @param {...ArgumentType|ArgumentTypeCaster} types - Types to use.
     * @returns {ArgumentTypeCaster}
     */
    static union(...types) {
        return async function typeFn(phrase, message, args) {
            for (let entry of types) {
                if (typeof type === 'function') entry = entry.bind(this);
                // eslint-disable-next-line no-await-in-loop
                const res = await Argument.cast(entry, this.handler.resolver, phrase, message, args);
                if (res != null) return res;
            }

            return null;
        };
    }

    /**
     * Creates a type from multiple types (tuple type).
     * Only inputs where each type resolves with a non-void value are valid.
     * @param {...ArgumentType|ArgumentTypeCaster} types - Types to use.
     * @returns {ArgumentTypeCaster}
     */
    static tuple(...types) {
        return async function typeFn(phrase, message, args) {
            const results = [];
            for (let entry of types) {
                if (typeof type === 'function') entry = entry.bind(this);
                // eslint-disable-next-line no-await-in-loop
                const res = await Argument.cast(entry, this.handler.resolver, phrase, message, args);
                if (res == null) return null;
                results.push(res);
            }

            return results;
        };
    }

    /**
     * Creates a type with extra validation.
     * If the predicate is not true, the value is considered invalid.
     * @param {ArgumentType|ArgumentTypeCaster} type - The type to use.
     * @param {ParsedValuePredicate} predicate - The predicate function.
     * @returns {ArgumentTypeCaster}
     */
    static validate(type, predicate) {
        return async function typeFn(phrase, message, args) {
            if (typeof type === 'function') type = type.bind(this);
            const res = await Argument.cast(type, this.handler.resolver, phrase, message, args);
            if (res == null) return null;
            if (!predicate.call(this, res, phrase, message, args)) return null;
            return res;
        };
    }

    /**
     * Creates a type where the parsed value must be within a range.
     * @param {ArgumentType|ArgumentTypeCaster} type - The type to use
     * @param {number} min - Minimum value.
     * @param {number} max - Maximum value.
     * @param {boolean} [inclusive=false] - Whether or not to be inclusive on the upper bound.
     * @returns {ArgumentTypeCaster}
     */
    static range(type, min, max, inclusive = false) {
        return Argument.validate(type, x => x >= min &amp;&amp; (inclusive ? x &lt;= max : x &lt; max));
    }

    /**
     * Creates a type that uses the parsed value to create a new value.
     * If the value of the dependent type is void, the result is null.
     * @param {ArgumentType|ArgumentTypeCaster} type - The type to use.
     * @param {ParsedValueMapper} fn - The mapping function.
     * @returns {ArgumentTypeCaster}
     */
    static map(type, fn) {
        return async function typeFn(phrase, message, args) {
            if (typeof type === 'function') type = type.bind(this);
            const res = await Argument.cast(type, this.handler.resolver, phrase, message, args);
            if (res == null) return null;
            return fn.call(this, res, phrase, message, args);
        };
    }

    /**
     * Creates a type that takes the result of the first type and runs it with the second.
     * It is recommended that the first type return a string since built-in types expect a string.
     * @param {ArgumentType|ArgumentTypeCaster} type1 - First type.
     * @param {ArgumentType|ArgumentTypeCaster} type2 - Second type.
     * @param {boolean} [ignoreVoid=true] - Whether or not to return null if the first type resolved with a void value.
     * @returns {ArgumentTypeCaster}
     */
    static compose(type1, type2, ignoreVoid = true) {
        return async function typeFn(phrase, message, args) {
            if (typeof type1 === 'function') type1 = type1.bind(this);
            if (typeof type2 === 'function') type2 = type2.bind(this);
            const res = await Argument.cast(type1, this.handler.resolver, phrase, message, args);
            if (res == null &amp;&amp; !ignoreVoid) return null;
            return Argument.cast(type2, this.handler.resolver, res, message, args);
        };
    }
    /* eslint-enable no-invalid-this */
}

module.exports = Argument;

/**
 * Options for how an argument parses text.
 * @typedef {Object} ArgumentOptions
 * @prop {string} id - ID of the argument for use in the args object.
 * @prop {ArgumentMatch} [match='phrase'] - Method to match text.
 * @prop {ArgumentType|ArgumentTypeCaster} [type='string'] - Type to cast to.
 * @prop {string|string[]} [flag] - The string(s) to use as the flag for flag or option match.
 * @prop {number} [index] - Index of phrase to start from.
 * Applicable to phrase, text, content, rest, or separate match only.
 * Ignored when used with the unordered option.
 * @prop {boolean|number|number[]} [unordered=false] - Marks the argument as unordered.
 * Each phrase is evaluated in order until one matches (no input at all means no evaluation).
 * Passing in a number forces evaluation from that index onwards.
 * Passing in an array of numbers forces evaluation on those indices only.
 * If there is a match, that index is considered used and future unordered args will not check that index again.
 * If there is no match, then the prompting or default value is used.
 * Applicable to phrase match only.
 * @prop {number} [limit=Infinity] - Amount of phrases to match when matching more than one.
 * Applicable to text, content, rest, or separate match only.
 * @prop {any|DefaultValueSupplier} [default=null] - Default value if no input or did not cast correctly.
 * If using a flag match, setting the default value to a non-void value inverses the result.
 * @prop {string|string[]} [description=''] - A description of the argument.
 * @prop {ArgumentPromptOptions} [prompt] - Prompt options for when user does not provide input.
 */

/**
 * Data passed to argument prompt functions.
 * @typedef {Object} ArgumentPromptData
 * @prop {number} retries - Amount of retries so far.
 * @prop {boolean} infinite - Whether the prompt is infinite or not.
 * @prop {Message} message - The message that caused the prompt.
 * @prop {string} phrase - The input phrase that caused the prompt if there was one.
 */

/**
 * A prompt to run if the user did not input the argument correctly.
 * Can only be used if there is not a default value (unless optional is true).
 * @typedef {Object} ArgumentPromptOptions
 * @prop {number} [retries=1] - Amount of times allowed to retries.
 * @prop {number} [time=30000] - Time to wait for input.
 * @prop {string} [cancelWord='cancel'] - Word to use for cancelling the command.
 * @prop {string} [stopWord='stop'] - Word to use for ending infinite prompts.
 * @prop {boolean} [optional=false] - Prompts only when argument is provided but was not of the right type.
 * @prop {boolean} [infinite=false] - Prompts forever until the stop word, cancel word, time limit, or retry limit.
 * Note that the retry count resets back to one on each valid entry.
 * The final evaluated argument will be an array of the inputs.
 * @prop {number} [limit=Infinity] - Amount of inputs allowed for an infinite prompt before finishing.
 * @prop {boolean} [breakout=true] - Whenever an input matches the format of a command, this option controls whether or not to cancel this command and run that command.
 * The command to be run may be the same command or some other command.
 * @prop {string|string[]|MessageEmbed|MessageAttachment|MessageAttachment[]|MessageOptions|PromptContentSupplier} [start] - Text sent on start of prompt.
 * @prop {string|string[]|MessageEmbed|MessageAttachment|MessageAttachment[]|MessageOptions|PromptContentSupplier} [retry] - Text sent on a retry (failure to cast type).
 * @prop {string|string[]|MessageEmbed|MessageAttachment|MessageAttachment[]|MessageOptions|PromptContentSupplier} [timeout] - Text sent on collector time out.
 * @prop {string|string[]|MessageEmbed|MessageAttachment|MessageAttachment[]|MessageOptions|PromptContentSupplier} [ended] - Text sent on amount of tries reaching the max.
 * @prop {string|string[]|MessageEmbed|MessageAttachment|MessageAttachment[]|MessageOptions|PromptContentSupplier} [cancel] - Text sent on cancellation of command.
 * @prop {PromptContentModifier} [modifyStart] - Function to modify start prompts.
 * @prop {PromptContentModifier} [modifyRetry] - Function to modify retry prompts.
 * @prop {PromptContentModifier} [modifyTimeout] - Function to modify timeout messages.
 * @prop {PromptContentModifier} [modifyEnded] - Function to modify out of tries messages.
 * @prop {PromptContentModifier} [modifyCancel] - Function to modify cancel messages.
 */

/**
 * The method to match arguments from text.
 * - `phrase` matches by the order of the phrases inputted.
 * It ignores phrases that matches a flag.
 * - `rest` matches the rest of the phrases in order.
 * It ignores phrases that matches a flag.
 * It also tries to preserve the original whitespace between phrases and the quotes around phrases.
 * - `separate` matches the rest of the phrases in order.
 * Unlike rest, each phrase is processed separately.
 * It ignores phrases that matches a flag.
 * - `flag` matches phrases that are the same as its flag.
 * The evaluated argument is either true or false.
 * - `option` matches phrases that starts with the flag.
 * The phrase after the flag is the evaluated argument.
 * - `text` matches the entire text, except for the command.
 * It also tries to preserve the original whitespace between phrases and the quotes around phrases.
 * It ignores phrases that matches a flag.
 * - `content` matches the entire text as it was inputted, except for the command.
 * It also preserves the original whitespace between phrases and the quotes around phrases.
 * - `none` matches nothing at all and an empty string will be used for type operations.
 * @typedef {string} ArgumentMatch
 */

/**
 * The type that the argument should be cast to.
 * - `string` does not cast to any type.
 * - `lowercase` makes the input lowercase.
 * - `uppercase` makes the input uppercase.
 * - `charCodes` transforms the input to an array of char codes.
 * - `number` casts to a number.
 * - `integer` casts to an integer.
 * - `bigint` casts to a big integer.
 * - `url` casts to an `URL` object.
 * - `date` casts to a `Date` object.
 * - `color` casts a hex code to an integer.
 * - `commandAlias` tries to resolve to a command from an alias.
 * - `command` matches the ID of a command.
 * - `inhibitor` matches the ID of an inhibitor.
 * - `listener` matches the ID of a listener.
 *
 * Possible Discord-related types.
 * These types can be plural (add an 's' to the end) and a collection of matching objects will be used.
 * - `user` tries to resolve to a user.
 * - `member` tries to resolve to a member.
 * - `relevant` tries to resolve to a relevant user, works in both guilds and DMs.
 * - `channel` tries to resolve to a channel.
 * - `textChannel` tries to resolve to a text channel.
 * - `voiceChannel` tries to resolve to a voice channel.
 * - `role` tries to resolve to a role.
 * - `emoji` tries to resolve to a custom emoji.
 * - `guild` tries to resolve to a guild.
 *
 * Other Discord-related types:
 * - `message` tries to fetch a message from an ID within the channel.
 * - `guildMessage` tries to fetch a message from an ID within the guild.
 * - `invite` tries to fetch an invite object from a link.
 * - `userMention` matches a mention of a user.
 * - `memberMention` matches a mention of a guild member.
 * - `channelMention` matches a mention of a channel.
 * - `roleMention` matches a mention of a role.
 * - `emojiMention` matches a mention of an emoji.
 *
 * An array of strings can be used to restrict input to only those strings, case insensitive.
 * The array can also contain an inner array of strings, for aliases.
 * If so, the first entry of the array will be used as the final argument.
 *
 * A regular expression can also be used.
 * The evaluated argument will be an object containing the `match` and `matches` if global.
 * @typedef {string|string[]} ArgumentType
 */

/**
 * A function for processing user input to use as an argument.
 * A void return value will use the default value for the argument or start a prompt.
 * Any other truthy return value will be used as the evaluated argument.
 * If returning a Promise, the resolved value will go through the above steps.
 * @typedef {Function} ArgumentTypeCaster
 * @param {string} phrase - The user input.
 * @param {Message} message - Message that triggered the command.
 * @param {Object} prevArgs - Previous arguments.
 * @returns {any}
 */

/**
 * Function get the default value of the argument.
 * @typedef {Function} DefaultValueSupplier
 * @param {Message} message - Message that triggered the command.
 * @param {Object} prevArgs - Previous arguments.
 * @returns {any}
 */

/**
 * A function for mapping parsed arguments.
 * @typedef {Function} ParsedValueMapper
 * @param {any} value - The parsed value.
 * @param {string} phrase - The user input.
 * @param {Message} message - Message that triggered the command.
 * @param {Object} prevArgs - Previous arguments.
 * @returns {any}
 */

/**
 * A function for validating parsed arguments.
 * @typedef {Function} ParsedValuePredicate
 * @param {any} value - The parsed value.
 * @param {string} phrase - The user input.
 * @param {Message} message - Message that triggered the command.
 * @param {Object} prevArgs - Previous arguments.
 * @returns {boolean}
 */

/**
 * A function modifying a prompt text.
 * @typedef {Function} PromptContentModifier
 * @param {string|MessageEmbed|MessageAttachment|MessageAttachment[]|MessageOptions} text - Text from the prompt to modify.
 * @param {Message} message - Message that triggered the command.
 * @param {Object} prevArgs - Previous arguments.
 * @param {ArgumentPromptData} data - Miscellaneous data.
 * @returns {string|string[]|MessageEmbed|MessageAttachment|MessageAttachment[]|MessageOptions}
 */

/**
 * A function returning text for the prompt.
 * @typedef {Function} PromptContentSupplier
 * @param {Message} message - Message that triggered the command.
 * @param {Object} prevArgs - Previous arguments.
 * @param {ArgumentPromptData} data - Miscellaneous data.
 * @returns {string|string[]|MessageEmbed|MessageAttachment|MessageAttachment[]|MessageOptions}
 */
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/jquery-3.1.1.min.js"></script>

<script src="scripts/search.js"></script>


<script src="scripts/collapse.js"></script>



</body>
</html>
