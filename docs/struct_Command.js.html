<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>struct/Command.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AkairoClient.html">AkairoClient</a></li><li><a href="AkairoHandler.html">AkairoHandler</a></li><li><a href="AkairoModule.html">AkairoModule</a></li><li><a href="Category.html">Category</a></li><li><a href="ClientUtil.html">ClientUtil</a></li><li><a href="Command.html">Command</a></li><li><a href="CommandHandler.html">CommandHandler</a></li><li><a href="Inhibitor.html">Inhibitor</a></li><li><a href="InhibitorHandler.html">InhibitorHandler</a></li><li><a href="Listener.html">Listener</a></li><li><a href="ListenerHandler.html">ListenerHandler</a></li><li><a href="SQLiteHandler.html">SQLiteHandler</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-1. Setting Up a Bot.html">1. Setting Up a Bot</a></li><li><a href="tutorial-2. Creating a Command.html">2. Creating a Command</a></li><li><a href="tutorial-3. Customizing Commands.html">3. Customizing Commands</a></li><li><a href="tutorial-4. Creating an Inhibitor.html">4. Creating an Inhibitor</a></li><li><a href="tutorial-5. Creating a Listener.html">5. Creating a Listener</a></li><li><a href="tutorial-6. Storing Data with SQLite.html">6. Storing Data with SQLite</a></li><li><a href="tutorial-7. Trigger Commands.html">7. Trigger Commands</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<div id="main">
    
    <h1 class="page-title">struct/Command.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const AkairoModule = require('./AkairoModule');
const { ArgumentMatches, ArgumentTypes, ArgumentSplits } = require('../util/Constants');

/**
 * An argument in a command.
 * @typedef {Object} Argument
 * @prop {string} id - ID of the argument.
 * @prop {ArgumentMatch} [match='word'] - Method to match argument.
 * @prop {ArgumentType|string[]|function} [type='string'] - Attempts to cast argument to this type.&lt;br/>An array or a function can be used (more details in ArgumentType).
 * @prop {string|string[]} [prefix] - Ignores word order and uses a word that starts with/matches this prefix (or multiple prefixes if array).&lt;br/>Applicable to 'prefix' and 'flag' only.
 * @prop {number} [index] - Word to start from.&lt;br/>Applicable to 'word', 'text', or 'content' only.&lt;br/>When using with word, this will offset all word arguments after it by 1 unless the index property is also specified for them.
 * @prop {string|number} [defaultValue=''] - Default value if a word is not inputted or a type could not be casted to.&lt;br/>Can also be a function &lt;code>(message => {})&lt;/code>.
 * @prop {string|string[]} [description=''] - A description of the argument.
 */

/**
 * The method to match arguments from text.
 * &lt;br/>Possible strings are:
 * &lt;br/>
 * &lt;br/>&lt;code>'word'&lt;/code> Matches by the order of the words inputted.&lt;br/>Ignores words that matches prefix or flag.
 * &lt;br/>
 * &lt;br/>&lt;code>'rest'&lt;/code> Matches the rest of the words in order.&lt;br/>Ignores words that matches prefix or flag.
 * &lt;br/>
 * &lt;br/>&lt;code>'prefix'&lt;/code> Matches words that starts with the prefix.&lt;br/>The word after the prefix is the evaluated argument.
 * &lt;br/>
 * &lt;br/>&lt;code>'flag'&lt;/code> Matches words that equal this prefix.&lt;br/>The evaluated argument is true or false.
 * &lt;br/>
 * &lt;br/>&lt;code>'text'&lt;/code> Matches the entire text, except for the command, ignoring words that matches prefix or flag.
 * &lt;br/>
 * &lt;br/>&lt;code>'content'&lt;/code> Matches the entire text as it was inputted, except for the command.
 * @typedef {string} ArgumentMatch
 */

/**
 * The type that the argument should be cast to.
 * &lt;br/>Possible strings are:
 * &lt;br/>
 * &lt;br/>&lt;code>'string'&lt;/code> Does not cast to any type.
 * &lt;br/>
 * &lt;br/>&lt;code>'number'&lt;/code> Casts to an number with parseFloat(), default value if not a number.
 * &lt;br/>
 * &lt;br/>&lt;code>'integer'&lt;/code> Casts to an integer with parseInt(), default value if not a number.
 * &lt;br/>
 * &lt;br/>&lt;code>'dynamic'&lt;/code> Casts to a number with parseFloat() or a string if the argument is not a number.
 * &lt;br/>
 * &lt;br/>&lt;code>'dynamicInt'&lt;/code> Casts to an integer with parseInt() or a string if the argument is not a number.
 * &lt;br/>
 * &lt;br/>Possible Discord-related strings:
 * &lt;br/>
 * &lt;br/>&lt;code>'user'&lt;/code> Tries to resolve to a user.
 * &lt;br/>
 * &lt;br/>&lt;code>'member'&lt;/code> Tries to resolve to a member.
 * &lt;br/>
 * &lt;br/>&lt;code>'channel'&lt;/code> Tries to resolve to a channel.
 * &lt;br/>
 * &lt;br/>&lt;code>'textChannel'&lt;/code> Tries to resolve to a text channel.
 * &lt;br/>
 * &lt;br/>&lt;code>'voiceChannel'&lt;/code> Tries to resolve to a voice channel.
 * &lt;br/>
 * &lt;br/>&lt;code>'role'&lt;/code> Tries to resolve to a role.
 * &lt;br/>
 * &lt;br/>&lt;code>'emoji'&lt;/code> Tries to resolve to a custom emoji.
 * &lt;br/>
 * &lt;br/>Many of these types can only be used in a guild.
 * &lt;br/>If any of the above are invalid, the default value will be resolved (recommended to use an ID).
 * &lt;br/>
 * &lt;br/>An array of strings can be used to restrict input to only those strings, case insensitive.
 * &lt;br/>The evaluated argument will be all lowercase.
 * &lt;br/>If the input is not in the array, the default value is used.
 * &lt;br/>
 * &lt;br/>A function &lt;code>((word, message) => {})&lt;/code> can also be used to filter or modify arguments.
 * &lt;br/>A return value of true will let the word pass, a falsey return value will use the default value for the argument.
 * &lt;br/>Any other truthy return value will be used as the argument.
 * @typedef {string|string[]} ArgumentType
 */

/**
 * Options to use for command execution behavior.
 * @typedef {Object} CommandOptions
 * @prop {Argument[]} [args=[]] - Arguments to parse.
 * @prop {string} [aliases=[]] - Command names.
 * @prop {string} [category='default'] - Category ID for organization purposes.
 * @prop {string|string[]} [description=''] - Description of the command.
 * @prop {boolean} [ownerOnly=false] - Whether or not to allow client owner(s) only.
 * @prop {string} [channelRestriction='none'] - Restricts channel: 'guild' or 'dm'.
 * @prop {ArgumentSplit} [split='plain'] - Method to split text into words.
 * @prop {RegExp|function} [trigger] - A regex or function &lt;code>(message => {})&lt;/code> returning regex to match in messages that are NOT commands.&lt;br/>The exec function is now &lt;code>((message, match) => {})&lt;/code> if non-global.&lt;br/>Or, &lt;code>((message, match, groups) => {})&lt;/code> if global.
 * @prop {Object} [options={}] - An object for custom options.&lt;br/>Accessible with Command#options.
 */

/**
 * The method to split text into words.
 * &lt;br/>Possible strings are:
 * &lt;br/>
 * &lt;br/>&lt;code>'plain'&lt;/code> Splits word separated by whitespace.&lt;br/>Extra whitespace is ignored.
 * &lt;br/>
 * &lt;br/>&lt;code>'split'&lt;/code> Splits word separated by whitespace.
 * &lt;br/>
 * &lt;br/>&lt;code>'quoted'&lt;/code> This is like plain, but counts text inside double quotes as one word.
 * &lt;br/>
 * &lt;br/>&lt;code>'sticky'&lt;/code> This is like quoted, but makes it so that quoted text must have a whitespace/another double quote before it to count as another word.&lt;br/>It will still span multiple words.
 * &lt;br/>
 * &lt;br/>A regex or a character can be used instead (for example, a comma) to split the message by that regex or character.
 * @typedef {string} ArgumentSplit
 */

/** @extends AkairoModule */
class Command extends AkairoModule {
    /**
     * Creates a new command.
     * @param {string} id - Command ID.
     * @param {function} exec - Function &lt;code>((message, args) => {})&lt;/code> called when command is ran.
     * @param {CommandOptions} [options={}] - Options for the command.
     */
    constructor(id, exec, options = {}){
        super(id, exec, options);

        /**
         * Command names.
         * @type {string[]}
         */
        this.aliases = options.aliases || [];

        /**
         * Arguments for the command.
         * @type {Argument[]}
         */
        this.args = options.args || [];
        for (const arg of this.args){
            if (!arg.match) arg.match = ArgumentMatches.WORD;
            if (!arg.type) arg.type = ArgumentTypes.STRING;
            if (!arg.defaultValue) arg.defaultValue = '';

            if (Array.isArray(arg.description)) arg.description = arg.description.join('\n');
            if (!arg.description) arg.description = '';
        }

        /**
         * Description of the command.
         * @type {string}
         */
        this.description = (Array.isArray(options.description) ? options.description.join('\n') : options.description) || '';

        /**
         * Usable only by the client owner.
         * @type {boolean}
         */
        this.ownerOnly = !!options.ownerOnly;

        /**
         * Usable only in this channel type.
         * @type {string}
         */
        this.channelRestriction = options.channelRestriction || 'none';

        /**
         * The command split method.
         * @type {ArgumentSplit}
         */
        this.split = options.split || ArgumentSplits.PLAIN;

        /**
         * Custom options for the command.
         * @type {Object}
         */
        this.options = options.custom || options.options || {};

        /**
         * Gets the regex trigger, if specified.
         * @method
         * @param {Message} message - Message being handled.
         * @returns {RegExp}
         */
        this.trigger = typeof options.trigger === 'function' ? options.trigger : () => options.trigger;

        /**
         * The ID of this command.
         * @name Command#id
         * @type {string}
         */

        /**
         * Executes the command.
         * @method
         * @name Command#exec
         * @returns {*}
         */

        /**
         * The command handler.
         * @readonly
         * @name Command#handler
         * @type {CommandHandler}
         */
    }

    /**
     * The command handler.&lt;br/>Alias to this.handler.
     * @readonly
     * @type {CommandHandler}
     */
    get commandHandler(){
        return this.handler;
    }

    /**
     * Parses text based on this command's args.
     * @param {string} content - String to parse.
     * @param {Message} [message] - Message to use.
     * @returns {Object}
     */
    parse(content, message){
        if (this.args.length === 0) return {};

        const splitFunc = {
            [ArgumentSplits.PLAIN]: () => content.match(/[^\s]+/g),
            [ArgumentSplits.SPLIT]: () => content.split(' '),
            [ArgumentSplits.QUOTED]: () => content.match(/".*?"|[^\s"]+|"/g),
            [ArgumentSplits.STICKY]: () => content.match(/[^\s"]*?".*?"|[^\s"]+|"/g)
        };

        const words = splitFunc[this.split] ? splitFunc[this.split]() || [] : content.split(this.split);
        const args = {};

        const wordArgs = this.args.filter(arg => arg.match === ArgumentMatches.WORD || arg.match === ArgumentMatches.REST);
        const prefixArgs = this.args.filter(arg => arg.match === ArgumentMatches.PREFIX);
        const flagArgs = this.args.filter(arg => arg.match === ArgumentMatches.FLAG);
        const textArgs = this.args.filter(arg => arg.match === ArgumentMatches.TEXT);
        const contentArgs = this.args.filter(arg => arg.match === ArgumentMatches.CONTENT);

        const prefixes = [];
        for (const arg of [...prefixArgs, ...flagArgs]){
            Array.isArray(arg.prefix) ? prefixes.push(...arg.prefix) : prefixes.push(arg.prefix);
        }

        const noPrefixWords = words.filter(w => !prefixes.some(p => w.startsWith(p)));

        const processType = (arg, word) => {
            const def = typeof arg.defaultValue === 'function' ? arg.defaultValue(message) : arg.defaultValue;

            const typeFunc = {
                [ArgumentTypes.STRING]: () => word || def,
                [ArgumentTypes.NUMBER]: () => {
                    if (isNaN(word) || !word) return def;
                    return parseFloat(word);
                },
                [ArgumentTypes.INTEGER]: () => {
                    if (isNaN(word) || !word) return def;
                    return parseInt(word);
                },
                [ArgumentTypes.DYNAMIC]: () => {
                    if (!word) return def;
                    if (isNaN(word)) return word;
                    return parseFloat(word);
                },
                [ArgumentTypes.DYNAMIC_INT]: () => {
                    if (!word) return def;
                    if (isNaN(word)) return word;
                    return parseInt(word);
                },
                [ArgumentTypes.USER]: () => {
                    const res = val => this.client.util.resolveUser(val, false, true);
                    if (!word) return res(def);
                    return res(word) || res(def);
                },
                [ArgumentTypes.MEMBER]: () => {
                    const res = val => this.client.util.resolveMember(val, message.guild, false, true);
                    if (!word) return res(def);
                    return res(word) || res(def);
                },
                [ArgumentTypes.CHANNEL]: () => {
                    const res = val => this.client.util.resolveChannel(val, message.guild, false, true);
                    if (!word) return res(def);
                    return res(word) || res(def);
                },
                [ArgumentTypes.TEXT_CHANNEL]: () => {
                    const res = val => this.client.util.resolveChannel(val, message.guild, false, true);
                    if (!word) return res(def);

                    const channel = res(word);
                    if (!channel || channel.type !== 'text') return res(def);

                    return channel;
                },
                [ArgumentTypes.VOICE_CHANNEL]: () => {
                    const res = val => this.client.util.resolveChannel(val, message.guild, false, true);
                    if (!word) return res(def);

                    const channel = res(word);
                    if (!channel || channel.type !== 'voice') return res(def);

                    return channel;
                },
                [ArgumentTypes.ROLE]: () => {
                    const res = val => this.client.util.resolveRole(val, message.guild, false, true);
                    if (!word) return res(def);
                    return res(word) || res(def);
                },
                [ArgumentTypes.EMOJI]: () => {
                    const res = val => this.client.util.resolveEmoji(val, message.guild, false, true);
                    if (!word) return res(def);
                    return res(word) || res(def);
                }
            };

            if (Array.isArray(arg.type)){
                if (!arg.type.some(t => t.toLowerCase() === word.toLowerCase())){
                    return def;
                }
                
                return word.toLowerCase();
            }

            if (typeof arg.type === 'function'){
                const res = arg.type(word, message);
                if (res === true) return word;
                if (!res) return def;

                return res;
            }

            if (typeFunc[arg.type]) return typeFunc[arg.type]();
            return word || def;
        };

        for (const [i, arg] of wordArgs.entries()){
            let word;

            if (arg.match === ArgumentMatches.REST){
                word = noPrefixWords.slice(arg.index != null ? arg.index : i).join(' ') || '';
            } else {
                word = noPrefixWords[arg.index != null ? arg.index : i] || '';
            }

            if ((this.split === ArgumentSplits.QUOTED || this.split === ArgumentSplits.STICKY) &amp;&amp; /^".*"$/.test(word)) word = word.slice(1, -1);

            args[arg.id] = processType(arg, word);
        }

        if (prefixArgs.length || flagArgs.length) words.reverse();

        for (const arg of prefixArgs){
            let word = words.find(w => Array.isArray(arg.prefix) ? arg.prefix.some(p => w.startsWith(p)) : w.startsWith(arg.prefix)) || '';
            word = word.replace(prefixes.find(p => word.startsWith(p)), '');
            
            if (this.split === ArgumentSplits.STICKY &amp;&amp; /^".*"$/.test(word)) word = word.slice(1, -1);

            args[arg.id] = processType(arg, word);
        }

        for (const arg of flagArgs){
            const word = words.find(w => Array.isArray(arg.prefix) ? arg.prefix.some(p => w === p) : w === arg.prefix);
            return args[arg.id] = !!word;
        }

        for (const arg of textArgs){
            const def = typeof arg.defaultValue === 'function' ? arg.defaultValue(message) : arg.defaultValue;
            const w = noPrefixWords.slice(arg.index).join(' ') || def;

            args[arg.id] = processType(arg, w);
        }

        for (const arg of contentArgs){
            const def = typeof arg.defaultValue === 'function' ? arg.defaultValue(message) : arg.defaultValue;
            const w = content.split(' ').slice(arg.index).join(' ') || def;

            args[arg.id] = processType(arg, w);
        }

        return args;
    }

    /**
     * Reloads the command.
     * @method
     * @name Command#reload
     * @returns {Command}
     */

    /**
     * Removes the command.
     * @method
     * @name Command#remove
     * @returns {Command}
     */

    /**
     * Enables the command.
     * @method
     * @name Command#enable
     * @returns {boolean}
     */

    /**
     * Disables the command.
     * @method
     * @name Command#disable
     * @returns {boolean}
     */
}

module.exports = Command;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
