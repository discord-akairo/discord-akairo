{"meta":{"generator":"0.8.0","format":19,"date":1554603525438},"custom":{"general":{"name":"General","files":{"welcome":{"name":"Welcome","type":"md","content":"<div align=\"center\">\n  <br />\n  <p>\n    <a href=\"https://discord-akairo.github.io\"><img src=\"https://discord-akairo.github.io/static/logo.svg\" width=\"546\" alt=\"discord-akairo\" /></a>\n  </p>\n  <br />\n  <p>\n    <a href=\"https://www.npmjs.com/package/discord-akairo\"><img src=\"https://img.shields.io/npm/v/discord-akairo.svg?maxAge=3600\" alt=\"NPM version\" /></a>\n    <a href=\"https://www.npmjs.com/package/discord-akairo\"><img src=\"https://img.shields.io/npm/dt/discord-akairo.svg?maxAge=3600\" alt=\"NPM downloads\" /></a>\n    <a href=\"https://travis-ci.org/discord-akairo/discord-akairo\"><img src=\"https://travis-ci.org/discord-akairo/discord-akairo.svg\" alt=\"Build status\" /></a>\n  </p>\n  <p>\n    <a href=\"https://nodei.co/npm/discord-akairo/\"><img src=\"https://nodei.co/npm/discord-akairo.png?downloads=true\" alt=\"npm installnfo\" /></a>\n  </p>\n</div>\n\n## Welcome!\n\nYou are currently looking at the discord-akairo v8 tutorials.\n\n## Links\n\n- [Website](https://discord-akairo.github.io)\n- [Repository](https://github.com/discord-akairo/discord-akairo)  \n- [Changelog](https://github.com/discord-akairo/discord-akairo/releases)\n- [Discord](https://discord.gg/arTauDY)  \n","path":"docs/general/welcome.md"}}},"basics":{"name":"Basics","files":{"setup":{"name":"Setting Up","type":"md","content":"# Setting Up\n\n### Installation\n\nBefore even doing anything else, you of course have to install the Discord.js and Akairo.  \n\n`npm i discord.js`  \n`npm i discord-akairo`  \n\nIf you feel like working with SQLite or Sequelize later, install them too.  \n\n`npm i sqlite`  \n`npm i sequelize`  \n\nOnce everything has been installed, your working directory should look something like this:  \n\n```\nmybot\n|____ node_modules\n      bot.js\n```\n\n### Main File\n\nInside `bot.js`, require `discord-akairo` and extend the `AkairoClient` class to customize your client.  \nAs your bot gets more complicated, you may want to separate this client class from your main file.  \n\n```js\nconst { AkairoClient } = require('discord-akairo');\n\nclass MyClient extends AkairoClient {\n    constructor() {\n        super({\n            // Options for Akairo go here.\n        }, {\n            // Options for discord.js goes here.\n        });\n    }\n}\n\nconst client = new MyClient();\nclient.login('TOKEN');\n```\n\nThere are some options you may want to setup first, for example, the owner of the bot.\nIf you would like to have multiple owners simply add those with an array.  \nWe want to use Discord.js's `disableEveryone` option too.  \n\n```js\nconst { AkairoClient } = require('discord-akairo');\n\nclass MyClient extends AkairoClient {\n    constructor() {\n        super({\n            ownerID: '123992700587343872', // or ['123992700587343872', '86890631690977280']\n        }, {\n            disableEveryone: true\n        });\n    }\n}\n\nconst client = new MyClient();\nclient.login('TOKEN');\n```\n\nYour bot should now login, and you are ready to make commands.  \n","path":"docs/basics/setup.md"},"commands":{"name":"Basic Commands","type":"md","content":"# Basic Commands\n\n### The Command Handler\n\nIn Akairo, the hierachy is that there are handlers which contains modules.  \nThe handlers deals with loading modules and executing them.  \nFor commands, we will import and instantiate the `CommandHandler`.  \n\n```js\nconst { AkairoClient, CommandHandler } = require('discord-akairo');\n\nclass MyClient extends AkairoClient {\n    constructor() {\n        super({\n            ownerID: '123992700587343872', // or ['123992700587343872', '86890631690977280']\n        }, {\n            disableEveryone: true\n        });\n\n        this.commandHandler = new CommandHandler(this, {\n            // Options for the command handler goes here.\n        });\n    }\n}\n\nconst client = new MyClient();\nclient.login('TOKEN');\n```\n\nNow, for some options.  \nThe `directory` option tells the handler where the main set of commands modules are at.  \nThe `prefix` option is simply the prefixes you want to use, you can have multiple too!  \n\n```js\nthis.commandHandler = new CommandHandler(this, {\n    directory: './commands/',\n    prefix: '?' // or ['?', '!']\n});\n```\n\nAnd now that the command handler has been setup, we simply have to tell it to load the modules.  \n\n```js\nthis.commandHandler.loadAll();\n```\n\n### Ping Command\n\nOur first order of business is to make a ping command.  \nNo bot is complete without one!  \n\nWe specified that the `directory` is in `./commands/`.  \nSo, go there, make a new file, and require Akairo.  \n\n```js\nconst { Command } = require('discord-akairo');\n```\n\nHere is a basic ping command:  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass PingCommand extends Command {\n    constructor() {\n        super('ping', {\n           aliases: ['ping'] \n        });\n    }\n    \n    exec(message) {\n        return message.reply('Pong!');\n    }\n}\n\nmodule.exports = PingCommand;\n```\n\nThe first parameter of `super` is the unique ID of the command.  \nIt is not seen nor used by users, but you should keep it the same as one of the aliases.  \n\nThe second parameter is the options.  \nThe only option there right now are the aliases, which are the names of the command for the users to call.  \nNote that the ID of the command is not an alias!  \n\nThe exec method is the execution function, ran when the command is called.  \nYou should try to always return a value such as a Promise with it, so that the framework can tell when a command finishes.  \n\nIf everything was done correctly, your command should now work!  \nBecause there are a lot of things that can be changed for commands, they will be explained further in other tutorials.  \n","path":"docs/basics/commands.md"},"inhibitors":{"name":"Basic Inhibitors","type":"md","content":"# Basic Inhibitors\n\n### Setup\n\nInhibitors are a way to monitor or block messages coming into the command handler.  \nBecause inhibitors are another kind of module, we need another kind of handler.  \nTo set it up, simply import and instantiate the `InhibitorHandler`, just like with the command handler.  \n\n```js\nconst { AkairoClient, CommandHandler, InhibitorHandler } = require('discord-akairo');\n\nclass MyClient extends AkairoClient {\n    constructor() {\n        super({\n            ownerID: '123992700587343872',\n        }, {\n            disableEveryone: true\n        });\n\n        this.commandHandler = new CommandHandler(this, {\n            directory: './commands/',\n            prefix: '?'\n        });\n\n        this.inhibitorHandler = new InhibitorHandler(this, {\n            directory: './inhibitors/'\n        });\n    }\n}\n\nconst client = new MyClient();\nclient.login('TOKEN');\n```\n\nThen, tell it to load all the modules.  \nBut, since inhibitors are a part of the command handling process, the command handler has to know about the inhibitor handler, so:  \n\n```js\nthis.commandHandler.useInhibitorHandler(this.inhibitorHandler);\nthis.inhibitorHandler.loadAll();\n```\n\n### Blacklist\n\nCreate a folder named `inhibitors`, then a file there to make one.  \n\n```js\nconst { Inhibitor } = require('discord-akairo');\n\nclass BlacklistInhibitor extends Inhibitor {\n    constructor() {\n        super('blacklist', {\n            reason: 'blacklist'\n        })\n    }\n\n    exec(message) {\n        // He's a meanie!\n        const blacklist = ['81440962496172032'];\n        return blacklist.includes(message.author.id);\n    }\n}\n\nmodule.exports = BlacklistInhibitor;\n```\n\nThe first parameter in `super` is the unique ID of the inhibitor.  \n\nThe second parameter are the options.  \nThe option `reason` is what will get emitted to an event, but we can worry about that later.  \n\nThe exec method is ran on testing.  \nIt should return `true` in order to block the message.  \nPromise are awaited and the resolved value will be checked.  \n","path":"docs/basics/inhibitors.md"},"listeners":{"name":"Basic Listeners","type":"md","content":"# Basic Listeners\n\n### Setup\n\nListeners are a basic concept in Node.js.  \nProblem is, you usually end up with loooooong files attaching listeners on your client.  \nAnd plus, you can't reload them as easily!  \n\nLet's add some listeners.  \nYou have to setup a `ListenerHandler` just like with commands and inhibitors.  \n\n```js\nconst { AkairoClient, CommandHandler, InhibitorHandler, ListenerHandler } = require('discord-akairo');\n\nclass MyClient extends AkairoClient {\n    constructor() {\n        super({\n            ownerID: '123992700587343872',\n        }, {\n            disableEveryone: true\n        });\n\n        this.commandHandler = new CommandHandler(this, {\n            directory: './commands/',\n            prefix: '?'\n        });\n\n        this.inhibitorHandler = new InhibitorHandler(this, {\n            directory: './inhibitors/'\n        });\n\n        this.listenerHandler = new ListenerHandler(this, {\n            directory: './listeners/'\n        });\n    }\n}\n\nconst client = new MyClient();\nclient.login('TOKEN');\n```\n\nThen, tell it to load all the modules.  \nThe command handler may need to use the listener handler for some operations later on, so it should use it as well:  \n\n```js\nthis.commandHandler.useListenerHandler(this.listenerHandler);\nthis.listenerHandler.loadAll();\n```\n\n### I'm Ready!\n\nAnd now, we can make a listener!   \nLet's start with a simple client `ready` event.  \n\n```js\nconst { Listener } = require('discord-akairo');\n\nclass ReadyListener extends Listener {\n    constructor() {\n        super('ready', {\n            emitter: 'client',\n            event: 'ready'\n        });\n    }\n\n    exec() {\n        console.log('I\\'m ready!');\n    }\n}\n\nmodule.exports = ReadyListener;\n```\n\nThe first parameter in `super` is the listener's unique ID.  \n\nThe second parameter are the options.  \nFirst, we have the emitter's name.  \nThen, we have the event we want to listen to.  \n\nThen the exec method, whose parameters are the event's.  \n\n### Custom Emitters\n\nBy default, the `client` emitter is the only one available.  \nHandlers in Akairo are also EventEmitters, so we can have our listener handler listen to our handlers.  \nUsing `setEmitters`, we can set custom emitters:  \n\n```js\nthis.listenerHandler.setEmitters({\n    commandHandler: this.commandHandler,\n    inhibitorHandler: this.inhibitorHandler,\n    listenerHandler: this.listenerHandler\n});\n```\n\n### Blocked Commands\n\nRemember the `reason` for inhibitors in previous tutorial?  \nThey are emitted to the `messageBlocked` (anything with `pre` type or before) or `commandBlocked` (everything after) event by the command handler.  \nSince we set the command handler to the key `commandHandler` up above, we have to use that as the `emitter` option.  \n\n```js\nconst { Listener } = require('discord-akairo');\n\nclass CommandBlockedListener extends Listener {\n    constructor() {\n        super('commandBlocked', {\n            emitter: 'commandHandler',\n            event: 'commandBlocked'\n        });\n    }\n\n    exec(message, command, reason) {\n        console.log(`${message.author.username} was blocked from using ${command.id} because of ${reason}!`);\n    }\n}\n\nmodule.exports = CommandBlockedListener;\n```\n\nAnd if you want your listeners to run only once, you add the option `type` with the value of `'once'`.  \n","path":"docs/basics/listeners.md"}}},"commands":{"name":"Commands","files":{"restrictions":{"name":"Restrictions","type":"md","content":"# Restrictions\n\n### Channel Restrictions\n\nIf a command requires a guild to be used correctly, you can restrict it to a guild with one option.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass NicknameCommand extends Command {\n    constructor() {\n        super('nickname', {\n            aliases: ['nickname']\n        });\n    }\n\n    exec(message) {\n        return message.reply(`Your nickname is ${message.member.nickname}.`);\n    }\n}\n\nmodule.exports = NicknameCommand;\n```\n\nThe above breaks in a DM, so let's add the `channel` option.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass NicknameCommand extends Command {\n    constructor() {\n        super('nickname', {\n            aliases: ['nickname'],\n            channel: 'guild'\n        });\n    }\n\n    exec(message) {\n        return message.reply(`Your nickname is ${message.member.nickname}.`);\n    }\n}\n\nmodule.exports = NicknameCommand;\n```\n\nEverything is fixed and you can go on your way!  \nAs a bonus, this will emit `commandBlocked` on the command handler with the reason `guild` if someone tries to use it in a DM.  \n\n### Owner Only\n\nRemember the `ownerID` option in your client?  \nYour commands can be owner-only, restricting them to be used by the owner(s).  \nSimply add `ownerOnly`.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass TokenCommand extends Command {\n    constructor() {\n        super('token', {\n            aliases: ['token'],\n            ownerOnly: true,\n            channel: 'dm'\n        });\n    }\n\n    exec(message) {\n        // Don't actually do this.\n        return message.reply(this.client.token);\n    }\n}\n\nmodule.exports = TokenCommand;\n```\n\nThis will emit `commandBlocked` with the reason `owner` if someone else uses it.  \n","path":"docs/commands/restrictions.md"},"permissions":{"name":"Permissions","type":"md","content":"# Permissions\n\n### Permission Flags\n\nSome commands should only be used by someone with certain permissions.  \nThere are options to help you do this.  \nThe two options to use are `clientPermissions` and `userPermissions`.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass BanCommand extends Command {\n    constructor() {\n        super('ban', {\n            aliases: ['ban'],\n            args: [\n                {\n                    id: 'member',\n                    type: 'member'\n                }\n            ],\n            clientPermissions: ['BAN_MEMBERS'],\n            userPermissions: ['BAN_MEMBERS'],\n            channel: 'guild'\n        });\n    }\n\n    async exec(message, args) {\n        if (!args.member) {\n            return message.reply('No member found with that name.');    \n        }\n\n        await args.member.ban();\n        return message.reply(`${args.member} was banned!`);\n    }\n}\n\nmodule.exports = BanCommand;\n```\n\nThis now checks for the required permissions for the client, then the user.  \nWhen blocked, it emits `missingPermissions` on the command handler.  \nIt will pass the message, command, either `client` or `user`, then the missing permissions.  \n\n### Dynamic Permissions\n\nSometimes, you may want to check for a role instead of permission flags.  \nThis means you can use a function instead of an array!  \nA function can be used on both `clientPermissions` and `userPermissions`.  \n\nThe return value is the `missing` parameter that is sent to the `missingPermissions` event.  \nIf the return value is null, then that means they're not missing anything.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass BanCommand extends Command {\n    constructor() {\n        super('ban', {\n            aliases: ['ban'],\n            args: [\n                {\n                    id: 'member',\n                    type: 'member'\n                }\n            ],\n            clientPermissions: ['BAN_MEMBERS'],\n            channel: 'guild'\n        });\n    }\n\n    userPermissions(message) {\n        if (!message.member.roles.some(role => role.name === 'Moderator')) {\n            return 'Moderator';\n        }\n\n        return null;\n    }\n\n    async exec(message, args) {\n        if (!args.member) {\n            return message.reply('No member found with that name.');    \n        }\n\n        await args.member.ban();\n        return message.reply(`${args.member} was banned!`);\n    }\n}\n\nmodule.exports = BanCommand;\n```\n","path":"docs/commands/permissions.md"},"cooldowns":{"name":"Cooldowns","type":"md","content":"# Cooldowns\n\n### No Spam!\n\nCooldowns are how you make sure that troublemakers don't spam your bot.  \nAkairo allows you to set cooldowns in uses per milliseconds.  \n\n```js\nconst { Command } = require('discord-akairo');\nconst exampleAPI = require('example-api');\n\nclass RequestCommand extends Command {\n    constructor() {\n        super('request', {\n            aliases: ['request'],\n            cooldown: 10000,\n            ratelimit: 2\n        });\n    }\n\n    async exec(message) {\n        const info = await exampleAPI.fetchInfo();\n        return message.reply(info);\n    }\n}\n\nmodule.exports = RequestCommand;\n```\n\n`cooldown` is the amount of time a user would be in cooldown for.  \n`ratelimit` is the amount of uses a user can do before they are denied usage.  \n\nIn simple terms, this means 2 uses every 10000 milliseconds.  \n\nIf you wish to set a default cooldown for all commands, the `defaultCooldown` option is available:  \n\n```js\nthis.commandHandler = new CommandHandler(this, {\n    directory: './commands/',\n    prefix: '?',\n    defaultCooldown: 1000\n});\n```\n\nWhen someone uses a command while in cooldown, the event `cooldown` will be emitted on the command handler with the remaining time in milliseconds.  \n\n### Ignoring Cooldown\n\nBy default, cooldowns are ignored by the client owners.  \nThis is actually done through the option `ignoreCooldown`.  \nTo change this, simply pass in an ID or an array of IDs:  \n\n```js\nthis.commandHandler = new CommandHandler(this, {\n    directory: './commands/',\n    prefix: '?',\n    defaultCooldown: 1000,\n    ignoreCooldown: ['123992700587343872', '130175406673231873']\n});\n```\n\nNote that you should pass the owner ID in as well, since it overrides the default.  \nThat is, unless you actually want to be ratelimited yourself.  \nAlso, a function could also be used to check who should be ignored.  \n","path":"docs/commands/cooldowns.md"},"regex":{"name":"Regex Commands","type":"md","content":"# Regex Commands\n\n### Memes\n\nRegex or regular expressions, is basically a way to match characters in a string.  \nRegex commands are commands that run if the following conditions are true:  \n- The command was not invoked normally.\n- The command's `regex` matches the message.\n\nMultiple regex commands/conditional commands can be triggered from one message.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass AyyCommand extends Command {\n    constructor() {\n        super('ayy', {\n            regex: /^ayy$/i\n        });\n    }\n\n    exec(message, args) {\n        return message.reply('lmao');\n    }\n}\n\nmodule.exports = AyyCommand;\n```\n\nThis command will trigger on any message with the content `ayy`, case-insensitive.  \nIn `args`, the `match` property will be the result from `message.content.match(/^ayy$/i)`.  \nThe `matches` property will be the matches, if using a global regex.  \n\n### As a Function\n\nThe `regex` option can also be a function.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass AyyCommand extends Command {\n    constructor() {\n        super('ayy', {\n            category: 'random'\n        });\n    }\n\n    regex(message) {\n        // Do some code...\n        return /^ayy$/i;\n    }\n\n    exec(message, args) {\n        return message.reply('lmao');\n    }\n}\n\nmodule.exports = AyyCommand;\n```\n","path":"docs/commands/regex.md"},"conditional":{"name":"Conditional Commands","type":"md","content":"# Conditional Commands\n\n### Run Whenever\n\nConditional commands are commands that run if the following conditions are true:  \n- The command was not invoked normally.\n- The command's `condition` option is true.\n\nMultiple conditional commands/regex commands can be triggered on one message.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass ComplimentCommand extends Command {\n    constructor() {\n        super('compliment', {\n            category: 'random'\n        });\n    }\n\n    condition(message) {\n        return message.author.id === '126485019500871680';\n    }\n\n    exec(message) {\n        return message.reply('You are a great person!');\n    }\n}\n\nmodule.exports = ComplimentCommand;\n```\n\nThis command, whenever a certain person sends any message, will execute.  \n","path":"docs/commands/conditional.md"},"prefixes":{"name":"Prefixes and Aliases","type":"md","content":"# Prefixes and Aliases\n\n### Mentioning\n\nSometimes people can forget or not know the prefix for your bot, so letting them use command with a mention is useful.  \nThis can be enabled with the `allowMention` option.  \n\n```js\nthis.commandHandler = new CommandHandler(this, {\n    directory: './commands/',\n    prefix: '?',\n    allowMention: true\n});\n```\n\nNow both `?ping` and `@BOT ping` works!  \n\n### Changeable Prefixes\n\nA prefix can change based on the message.  \nUse a function as the `prefix` option to do so.  \nThis is most useful with an actual database to back it up, so check out the [Using Providers](../other/providers.md) section.  \n\n```js\nthis.commandHandler = new CommandHandler(this, {\n    directory: './commands/',\n    prefix: msg => {\n        // Get prefix here...\n        return prefix;\n    },\n    allowMention: true\n});\n```\n\n### Prefix Overrides\n\nPrefix overrides are command-specific prefixes.  \nTo use them, simply add the `prefix` option.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass SecretCommand extends Command {\n    constructor() {\n        super('secret', {\n            aliases: ['secret'],\n            prefix: '???'\n        });\n    }\n\n    exec(message) {\n        return message.reply('Woah! How did you find this!?');\n    }\n}\n\nmodule.exports = SecretCommand;\n```\n\nNow, if our prefix was `?`, `?secret` won't work, but `???secret` would.  \nAn array works too, so you can do `prefix: ['???', '??']` and both would work.  \n\n### Automatic Aliases\n\nTo speed up your development, you can make command aliases automatically.  \nFor example, if you had a command alias that is two words, you might want both `command-name` and `commandname` to be valid.  \nUse the `aliasReplacement` option, which takes a regular expression to make aliases:  \n\n```js\nthis.commandHandler = new CommandHandler(this, {\n    directory: './commands/',\n    prefix: '?',\n    aliasReplacement: /-/g,\n    allowMention: true\n});\n```\n\nThe option is passed `/-/g` which means that all dashes are to be removed to make an alias.  \nSo now, in a command, you can pass `aliases: ['command-name']` and both `command-name` and `commandname` would be valid.  \n","path":"docs/commands/prefixes.md"},"commandutil":{"name":"CommandUtil","type":"md","content":"# CommandUtil\n\n### Handling Edits\n\nThe CommandUtil class is a utility class for working with responses.  \nIn order to make it available, you must enable `commandUtil`.  \n\n```js\nthis.commandHandler = new CommandHandler(this, {\n    directory: './commands/',\n    prefix: '?',\n    handleEdits: true,\n    commandUtil: true\n});\n```\n\nNow, CommandUtil is available on messages with the property `util`.  \nAn instance is kept for each message that go through command handling, but they have a lifetime of 5 minutes from then.  \nTo keep them alive longer, set a larger time in milliseconds using the `commandUtilLifetime` option.  \nNote that this can build up memory usage really fast on larger bots, so it is recommended you give it a reasonable lifetime.  \n\nYou can CommandUtil methods such as `send` in order to send responses.  \nWith `handleEdits` on, the `send` methods will edits responses accordingly.  \nThis works for prompts as well.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass HelloCommand extends Command {\n    constructor() {\n        super('hello', {\n            aliases: ['hello']\n        });\n    }\n\n    exec(message) {\n        // Also available: util.reply()\n        return message.util.send('Hello!');\n    }\n}\n\nmodule.exports = HelloCommand;\n```\n\nAs an example of what that means:  \n\n- User sends `?ping` (message A).\n- Bot replies with `Pong!` (message B).\n- User edits message A to `?hello`.\n- Bot edits message B to `Hello!`.\n\n### Raw Input\n\nCommandUtil can also be used to view the prefix, command alias, and arguments used.  \nThe format for command is almost always `<prefix><alias> <arguments>`.  \nCommandUtil stores all three of that and more for you.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass HelloCommand extends Command {\n    constructor() {\n        super('hello', {\n            aliases: ['hello', 'hi', 'konnichiha', 'bonjour', 'heyo']\n        });\n    }\n\n    exec(message) {\n        if (message.util.parsed.alias === 'konnichiha') {\n            return message.util.send('こんにちは！');\n        }\n\n        if (message.util.parsed.alias === 'bonjour') {\n            return message.util.send('Bonjour!');\n        }\n\n        return message.util.send('Hello!');\n    }\n}\n\nmodule.exports = HelloCommand;\n```\n\nWith that, you can see which alias was used by the user.  \n\nYou can see the prefix as well.  \nFor example, if you have two prefixes, `?` and `!`, `message.util.parsed.prefix` will be either `?` or `!`.  \nThe content can also be viewed, for example, in `!command xyz abc`, `message.util.parsed.content` would be `xyz abc`.  \n\nCommandUtil, if enabled, is available on all messages just after built-in pre-inhibitors.  \nThis means an invalid input, e.g. `?not-a-command` will still be parsed with prefix of `?` and alias of `not-a-command`.  \n\n### Stored Messages\n\nIf you set the command handler option `storeMessages` to true, CommandUtil instances will start storing messages from prompts.  \nThis means that prompts from the client as well as the user replies are stored within `message.util.messages`.  \nSee the prompting sections under Arguments for more information about prompts. \n","path":"docs/commands/commandutil.md"}}},"arguments":{"name":"Arguments","files":{"arguments":{"name":"Basic Arguments","type":"md","content":"# Basic Arguments\n\n### Adding Numbers\n\nCommands should also have some user input, in the form of arguments.  \nIn Akairo, arguments are the most complex things ever, so this tutorial will only go through the basics.  \n\nLet's make a command that takes three numbers and adds them up.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass AddCommand extends Command {\n    constructor() {\n        super('add', {\n            aliases: ['add']\n        });\n    }\n\n    exec(message) {\n        // This doesn't work!\n        return message.reply(a + b + c);\n    }\n}\n\nmodule.exports = AddCommand;\n```\n\nNow we will add arguments in the command options with the `args` option.  \nThis option must be an array of objects, containing info for parsing.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass AddCommand extends Command {\n    constructor() {\n        super('add', {\n            aliases: ['add'],\n            args: [\n                {\n                    id: 'numOne',\n                    type: 'number',\n                    default: 0\n                },\n                {\n                    id: 'numTwo',\n                    type: 'number',\n                    default: 0\n                }\n                {\n                    id: 'numThree',\n                    type: 'number',\n                    default: 0\n                }\n            ]\n        });\n    }\n\n    exec(message, args) {\n        const sum = args.numOne + args.numTwo + args.numThree;\n        return message.reply(`The sum is ${sum}!`);\n    }\n}\n\nmodule.exports = AddCommand;\n```\n\nArguments must always have an `id`, it will be what you use to refer to them in `args`.  \nThe `type` options is optional, but since we want numbers, it is set to `number`.  \nThe `default` is what is used if there are no input or no number input.  \n\nBy default, arguments are able to be quoted (you can disable this by having the `quoted` option set to false).  \nSo, technically, this works (although it won't be an actual number input): `?add \"hello world\" 2 3`.  \n","path":"docs/arguments/arguments.md"},"matches":{"name":"Matching Input","type":"md","content":"# Matching Input\n\n### Entire Content\n\nLet's say you have a command that picks from a list inputted.  \nObviously, you won't know how many things there are.  \nSo, we need a different way of matching input instead of phrase by phrase.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass PickCommand extends Command {\n    constructor() {\n        super('pick', {\n            aliases: ['pick'],\n            args: [\n                {\n                    // Only takes one phrase!\n                    id: 'items'\n                }\n            ]\n        });\n    }\n\n    exec(message, args) {\n        const picked = args.items; // ???\n        return message.reply(`I picked ${picked}`);\n    }\n}\n\nmodule.exports = PickCommand;\n```\n\nTo remedy this, we will use the `match` option.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass PickCommand extends Command {\n    constructor() {\n        super('pick', {\n            aliases: ['pick'],\n            args: [\n                {\n                    id: 'items',\n                    match: 'content'\n                }\n            ]\n        });\n    }\n\n    exec(message, args) {\n        const items = args.items.split('|');\n        const picked = items[Math.floor(Math.random() * items.length)]\n        return message.reply(`I picked ${picked.trim()}!`);\n    }\n}\n\nmodule.exports = PickCommand;\n```\n\nNow, the entire content, excluding the prefix and command of course, is matched. \n\n### Flags\n\nIf you had a command with lots of argument that can be true or false, you may forget the order.  \nThis is where `flag` match comes in handy.  \n\nHere is a command where the user can change the output with a flag:  \n\n```js\nconst { Command } = require('discord-akairo');\nconst exampleAPI = require('example-api');\n\nclass StatsCommand extends Command {\n    constructor() {\n        super('stats', {\n            aliases: ['stats'],\n            args: [\n                {\n                    id: 'username'\n                },\n                {\n                    id: 'advanced',\n                    match: 'flag',\n                    flag: '--advanced'\n                }\n            ]\n        });\n    }\n\n    exec(message, args) {\n        const user = exampleAPI.getUser(args.username);\n\n        if (args.advanced) {\n            return message.reply(user.advancedInfo);\n        }\n\n        return message.reply(user.basicInfo);\n    }\n}\n\nmodule.exports = StatsCommand;\n```\n\nNow, if a user does `?stats 1Computer` they will get the `basicInfo`, but if they do `?stats 1Computer --advanced`, they will get the `advancedInfo`.  \nIt can be out of order too, so `?stats --advanced 1Computer` will work.  \n\n### Option Flag\n\nThe above example shows `flag`, which does only a boolean value, there or not there.  \nHere, we will use `option` for unordered input.  \n\nSimilar to the above example, but this time, we have many different possibilities.  \n\n```js\nconst { Command } = require('discord-akairo');\nconst exampleAPI = require('example-api');\n\nclass StatsCommand extends Command {\n    constructor() {\n        super('stats', {\n            aliases: ['stats'],\n            args: [\n                {\n                    id: 'username'\n                },\n                {\n                    id: 'color',\n                    match: 'option',\n                    flag: 'color:',\n                    default: 'red'\n                }\n            ]\n        });\n    }\n\n    exec(message, args) {\n        const team = exampleAPI.getTeam(args.color);\n        const user = team.getUser(args.username);\n        \n        return message.reply(user.info);\n    }\n}\n\nmodule.exports = StatsCommand;\n```\n\nSo now, all of these inputs can be valid:  \n\n- `?stats 1Computer`\n- `?stats 1Computer color:blue`\n- `?stats color:green 1Computer`\n\nIt's also whitespace insensitive between the flag and the input:  \n\n- `?stats 1Computer color: blue`\n- `?stats color: green 1Computer`\n\nIf you would like to use multiple flags, you can use an array.  \nSo, if you did `prefix: ['color:', 'colour:']`, both will be valid for the user.  \n\nNote that for both flag match type, you can have flags with whitespace or using an empty string.  \nIt will work, but will be extremely weird for the end users, so don't do it!  \n\n### Separate\n\nLet's say that we want our pick command to only work on numbers.    \nThis would mean having to deal with splitting then casting the types within the args!  \nWe can do this with a custom separator using `separator` option alongside the `separate` match.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass PickCommand extends Command {\n    constructor() {\n        super('pick', {\n            aliases: ['pick'],\n            separator: '|',\n            args: [\n                {\n                    id: 'items',\n                    match: 'separate',\n                    type: 'number'\n                }\n            ]\n        });\n    }\n\n    exec(message, args) {\n        const picked = args.items[Math.floor(Math.random() * items.length)]\n        return message.reply(`I picked ${picked} which is ${picked % 2 === 0 ? 'even' : 'odd'}!`);\n    }\n}\n\nmodule.exports = PickCommand;\n``` \n\nThe `separate` match matches the phrases individually into an array where each element is type casted one by one.  \nThe `separator` option simply makes it so that all the input is separated via a certain character rather than by whitespace.  \n\nNote that with the `separator` option, quotes will not work.  \nFlags will also have to be contained individually:  \n\n- `!foo a, --flag, c` recognizes `--flag`\n- `!foo a, x --flag y, c` does not\n- `!foo a, --option y, c` recognizes `--option`\n- `!foo a, x --option y, c` does not\n\n### Summary\n\nHere are all the match types available in Akairo.  \n\n- `phrase` (default) matches one by one (where a phrase is either a word or something in quotes).\n- `rest` matches the rest of the content, minus things matched by `flag` and `option`.\n- `separate` matches the same way as `rest`, but works on each phrase separately.\n- `flag` matches a flag.\n- `option` matches a flag with additional input.\n- `content` matches the content.\n- `text` matches the content, minus things matched by `flag` and `option`.\n- `none` matches nothing at all.\n\nThe different match types have the following behavior with border whitespaces, quotes, and separators:  \n- `phrase`, `separate`, and `option` do not preserve any of the three.  \n- `rest`, `content`, `text` do preserve all three.  \n","path":"docs/arguments/matches.md"},"types":{"name":"Argument Types","type":"md","content":"# Argument Types\n\n### Basic Types\n\nAs seen in the previous tutorials, there was the `type` option for type casting.  \nYou've only seen the type `number`, so here are the rest of them:  \n\n- `string` (default)\n    - This type does not do anything.\n- `lowercase`\n    - Transform input to all lowercase.\n- `uppercase`\n    - Transform input to all uppercase.\n- `charCodes`\n    - Transform the input to an array of char codes.\n- `number`\n    - Casts to a number.\n- `integer`\n    - Casts to a integer.\n- `bigint`\n    - Casts to a big integer.\n- `url`\n    - Parses to an URL object.\n- `date`\n    - Parses to a Date object.\n- `color`\n    - Parses a hex code to an color integer.\n- `commandAlias`\n    - Finds a command by alias.\n- `command`\n    - Finds a command by ID.\n- `inhibitor`\n    - Finds an inhibitor by ID.\n- `listener`\n    - Finds a listener by ID.\n\n### Discord Types\n\nOf course, since this is a framework for Discord.js, there are Discord-related types.  \n\n- `user`\n    - Resolves a user from the client's collection.\n- `member`\n    - Resolves a member from the guild's collection.\n- `relevant`\n    - Resolves a user from the relevant place.\n    - Works in both guilds and DMs.\n- `channel`\n    - Resolves a channel from the guild's collection.\n- `textChannel`\n    - Resolves a text channel from the guild's collection.\n- `voiceChannel`\n    - Resolves a voice channel from the guild's collection.\n- `role`\n    - Resolves a role from the guild's collection.\n- `emoji`\n    - Resolves an emoji from the guild's collection.\n- `guild`\n    - Resolves a guild from the client's collection.\n\nAll of the above types also have plural forms.  \nSo if you do `users` instead of `user`, you will receive a Collection of resolved users.  \nThe types below are also Discord-related, but have no plural form.  \n\n- `message`\n    - Fetches a message from an ID within the channel.\n- `guildMessage`\n    - Fetches a message from an ID within the guild.\n- `invite`\n    - Fetches an invite from a link.\n- `userMention`\n    - Matches the user from a mention.\n- `memberMention`\n    - Matches the member from a mention.\n- `channelMention`\n    - Matches the channel from a mention.\n- `roleMention`\n    - Matches the role from a mention.\n- `emojiMention`\n    - Matches the emoji from a mention.\n\n### Array Types\n\nThere are other ways to do type-casting instead of a string literal too.  \nThe first way is with an array:  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass PokemonCommand extends Command {\n    constructor() {\n        super('pokemon', {\n            aliases: ['pokemon'],\n            args: [\n                {\n                    id: 'option',\n                    type: ['grass', 'fire', 'water', 'electric'],\n                    default: 'electric'\n                }\n            ]\n        });\n    }\n\n    exec(message, args) {\n        if (args.option === 'grass') return message.reply('bulbasaur');\n        if (args.option === 'fire') return message.reply('charmander');\n        if (args.option === 'water') return message.reply('squirtle');\n        if (args.option === 'electric') return message.reply('pikachu');\n    }\n}\n\nmodule.exports = PokemonCommand;\n```\n\nWith the above, the user can only enter one of the entries in the array.  \nIt is also case-insensitive for input, but not for output.  \nThis means that if the array was `['GrasS', 'FIrE']` and the input was `grass`, you will get `GrasS`.  \n\nYou can also do aliases with the array type like so:  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass PokemonCommand extends Command {\n    constructor() {\n        super('pokemon', {\n            aliases: ['pokemon'],\n            args: [\n                {\n                    id: 'option',\n                    type: [\n                        ['grass', 'leaf', 'green'],\n                        ['fire', 'red'],\n                        ['water', 'blue'],\n                        ['electric', 'electricity', 'lightning', 'yellow']\n                    ],\n                    default: 'electric'\n                }\n            ]\n        });\n    }\n\n    exec(message, args) {\n        if (args.option === 'grass') return message.reply('bulbasaur');\n        if (args.option === 'fire') return message.reply('charmander');\n        if (args.option === 'water') return message.reply('squirtle');\n        if (args.option === 'electric') return message.reply('pikachu');\n    }\n}\n\nmodule.exports = PokemonCommand;\n```\n\nIf the user inputs anything from the arrays, the first entry will be used.  \nSo, the input of `leaf` will give you `grass`, `blue` will give you `water`, etc.  \n\n### Regex Types\n\nYou can also use a regular expression as a type.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass AskCommand extends Command {\n    constructor() {\n        super('ask', {\n            aliases: ['ask'],\n            args: [\n                {\n                    id: 'yesOrNo',\n                    type: /^(yes|no)$/i\n                }\n            ]\n        });\n    }\n\n    exec(message, args) {\n        // {\n        //   match: [...],\n        //   matches: null\n        // }\n        console.log(args.yesOrNo);\n    }\n}\n\nmodule.exports = AskCommand;\n```\n\nThis will match `yes` or `no`, case-insensitive and `args.yesOrNo` will give you the result from `word.match(/^(yes|no)$/i`.  \nIf using a global regex, the `matches` property will be filled for the matches.   \n","path":"docs/arguments/types.md"},"functions":{"name":"Using Functions","type":"md","content":"# Using Functions\n\n### Dynamic Defaults\n\nWhen you are doing default values for certain arguments, you could really only do what JavaScript has to offer: numbers, strings, etc.  \nWhat if we want to use a default such as the author's username or the guild's owner?  \nThis is where you can use a function.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass HighestRoleCommand extends Command {\n    constructor() {\n        super('highestRole', {\n            aliases: ['highestRole'],\n            args: [\n                {\n                    id: 'member',\n                    type: 'member',\n                    default: message => message.member\n                }\n            ],\n            channel: 'guild'\n        });\n    }\n\n    exec(message, args) {\n        return message.reply(args.member.highestRole.name);\n    }\n}\n\nmodule.exports = HighestRoleCommand;\n```\n\nThe command above gives the name of the inputted member's highest role.  \nIf there were no member or an incorrect member provided, the `default` function is called, giving us the message member.  \n\n### Dynamic Types\n\nLet's go to using a function for types.  \nTake a look at the roll command below.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass RollCommand extends Command {\n    constructor() {\n        super('roll', {\n            aliases: ['roll'],\n            args: [\n                {\n                    id: 'amount',\n                    type: 'integer',\n                    default: 100\n                }\n            ]\n        });\n    }\n\n    exec(message, args) {\n        const res = Math.floor(Math.random() * args.amount));\n        return message.reply(`You rolled ${res}!`);\n    }\n}\n\nmodule.exports = RollCommand;\n```\n\nLet's say we want to limit the user to between 1 and 100, so that there are no giant numbers.  \nWhile we could do it in the execution function, let's stick it straight into the type as a function.  \nThis is much easier with a validation type (see [Composing Types](./compose.md)), but for the sake of example, let's do it anyways.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass RollCommand extends Command {\n    constructor() {\n        super('roll', {\n            aliases: ['roll'],\n            args: [\n                {\n                    id: 'amount',\n                    type: phrase => {\n                        if (!phrase || isNaN(phrase)) return null;\n                        const num = parseInt(phrase);\n                        if (num < 1 || num > 100) return null;\n                        return num;\n                    },\n                    default: 100\n                }\n            ]\n        });\n    }\n\n    exec(message, args) {\n        const res = Math.floor(Math.random() * args.amount));\n        return message.reply(`You rolled ${res}!`);\n    }\n}\n\nmodule.exports = RollCommand;\n```\n\nThe type function follows these steps:  \n\n1. Check if there was input.\n2. Check if input is not a number.\n3. Parse input to an integer.\n4. Check if the integer is out of bounds.\n5. Return the integer.\n\nWhenever a `null` or `undefined` value is returned, it means the type casting failed, and the default will be used.  \nOtherwise, whatever you return is the result.  \nPromise are awaited and the resolved value will go through the same process.  \n\n### A Bit Further\n\nType functions can be used almost anywhere a type is expected.  \nThis includes the types builders in the [Composing Types](./compose.md) section.  \nTake a look at this slightly exaggerated example for a type for a page argument:  \n\n```js\nargs: [\n    {\n        id: 'page',\n        type: Argument.compose(Argument.range('integer', 0, Infinity), n => n - 1)\n    }\n]\n```\n\nThis casts the input to an integer, ensure it is at least 0, and decrements it by 1.  \n","path":"docs/arguments/functions.md"},"compose":{"name":"Composing Types","type":"md","content":"# Composing Types\n\n### Union Types\n\nAkairo allows the creation of union types, where the input can match one of many types.  \nYou can import the `Argument` class, where there is the `Argument.union` static method.  \n\n```js\n{\n    id: 'numOrName',\n    type: Argument.union('integer', 'string')\n}\n```\n\nThe above argument will try matching using `integer` first, then `string`.  \nSo, it is recommended that you go from most to least specific types.  \n\n### Product Types\n\nA product type in Akairo casts the input to multiple types.  \nThe static method `Argument.product` lets us create one of these.  \nThe type will parse the input into an array containing the values respective to the given types.  \n\n```js\n{\n    id: 'numAndName',\n    type: Argument.product('integer', 'string')\n}\n```\n\nThe above argument will give an array where the first element was parsed using `integer`, and the second using `string`.  \nIf any of the types fail, the entire argument fails.  \n\n### Validation\n\nExtra validation can be done on the parsed value using `Argument.validate`.  \nFor numbers and things with a length or size, `Argument.range` is a convenient method as well.  \n\n```js\n{\n    id: 'content',\n    type: Argument.validate('string', str => str.length < 2000)\n}\n```\n\nThis argument ensures that the input is less than 2000 characters in length.  \nIf it is over 2000 characters, the input is considered invalid.  \n\n```js\n{\n    id: 'number',\n    type: Argument.range('number', 0, 100)\n}\n```\n\nThe `range` method ensures that the parsed value is within a certain range.  \nHere, `number` will be between 0 and 100, exclusive.  \nTo make the upper bound inclusive, simply pass `true` to the 4th argument in the range function.  \n\n### We're Going Functional\n\nTypes can be composed together using `Argument.compose`.  \nFor example, the result of `Argument.compose(type1, type2)` is a type that uses the first type, then the result of that is passed the second.  \nA use case of this function is for preprocessing before casting:  \n\n```js\n{\n    id: 'lowercaseChars',\n    type: Argument.compose('lowercase', 'charCodes')\n}\n```\n\nFor more complicated types compositions and validations, it will be a lot easier to use type functions.  \nSee the [Using Functions](./functions.md) section for more information.  \n","path":"docs/arguments/compose.md"},"custom":{"name":"Custom Types","type":"md","content":"# Custom Types\n\n### New Type\n\nWe have to access the command handler's `TypeResolver` in order to add new types for our arguments.  \nTo add a new type:  \n\n```js\nthis.commandHandler = new CommandHandler(this, { /* Options here */ });\nthis.commandHandler.resolver.addType('pokemon', phrase => {\n    if (!phrase) return null;\n\n    for (const pokemon of pokemonList) {\n        if (pokemon.name.toLowerCase() === phrase.toLowerCase()) {\n            return pokemon;\n        }\n    }\n\n    return null;\n});\n```\n\nWe now have a new type called `pokemon` which we can use in a command!  \nSimply do `type: 'pokemon'` for an argument and everything will work as expected.  \n\n### With Message\n\nLet's say we want to add a type that would get a role based on the input.  \nThis means we need access to the guild through the message.  \nGood thing the second parameter is the message!  \n\n```js\nthis.commandHandler.resolver.addType('colorRole', (phrase, message) => {\n    if (!phrase) return null;\n\n    const roles = {\n        red: '225939226628194304',\n        blue: '225939219841810432',\n        green: '225939232512802816'\n    };\n\n    const role = message.guild.roles.get(roles[phrase.toLowerCase()]);\n    return role || null;\n});\n```\n\nSo now, using the type `colorRole`, we can get either red, blue, or green from the input and end up with corresponding role object!  \n\n### Accessing Another Type\n\nTo get another type for use, you use the `type` method on `TypeResolver`.  \nThe following gives the `member` type and we can use as part of another type.  \n\n```js\nthis.commandHandler.resolver.addType('moderator', (phrase, message) => {\n    if (!phrase) return null;\n    const memberType = this.commandHandler.resolver.type('member');\n    const member = memberType(phrase, message);\n    if (!member.roles.has('222089067028807682')) return null;\n    return member;\n});\n```\n","path":"docs/arguments/custom.md"},"prompts":{"name":"Argument Prompting","type":"md","content":"# Argument Prompting\n\n### Please Try Again\n\nYou may notice prompting for arguments in other bots (Tatsumaki) or bot frameworks (Commando).  \nAkairo has a flexible way for you to do them too!  \nIt allows you to set the following properties:  \n\n- How many times the user can retry.\n- How long they can stall the prompt for.\n- The input to use to cancel a prompt (default is `cancel`).\n- Whether or not the prompt is optional.\n- The message to send on start, on retry, on timeout, on maximum retries, and on cancel.\n    - There can be embeds or files too!\n    - Or you can have no message at all!\n\nLet's start with a basic prompt.  \nWe will be reusing this command:  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass HighestRoleCommand extends Command {\n    constructor() {\n        super('highestRole', {\n            aliases: ['highestRole'],\n            args: [\n                {\n                    id: 'member',\n                    type: 'member',\n                    default: message => message.member\n                }\n            ],\n            channel: 'guild'\n        });\n    }\n\n    exec(message, args) {\n        return message.reply(args.member.highestRole.name);\n    }\n}\n\nmodule.exports = HighestRoleCommand;\n```\n\nFirst, remove the `default`.  \nSince prompting will have the user retry until it is finished, `default` won't do anything.  \nNow, add the `prompt` property with the options you want.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass HighestRoleCommand extends Command {\n    constructor() {\n        super('highestRole', {\n            aliases: ['highestRole'],\n            args: [\n                {\n                    id: 'member',\n                    type: 'member',\n                    prompt: {\n                        start: 'Who would you like to get the highest role of?',\n                        retry: 'That\\'s not a valid member! Try again.'\n                    }\n                }\n            ],\n            channel: 'guild'\n        });\n    }\n\n    exec(message, args) {\n        return message.reply(args.member.highestRole.name);\n    }\n}\n\nmodule.exports = HighestRoleCommand;\n```\n\nSimple as that, you have a prompt.  \nGuess what, you can use a function for those messages too!  \n\n```js\nprompt: {\n    start: message => `Hey ${message.author}, who would you like to get the highest role of?`,\n    retry: message => `That\\'s not a valid member! Try again, ${message.author}.`\n}\n```\n\nMore complex structures can also be returned as well.  \nThis includes embeds, attachments, anything that can be sent.  \n\n```js\nprompt: {\n    start: message => {\n        const embed = new MessageEmbed().setDescription('Please input a member!');\n        const content = 'Please!';\n        return { embed, content };\n    }\n}\n```\n\n### Cascading\n\nPrompts can also \"cascade\" from three places: the command handler, then the command, then the argument.  \nFor the command handler or the command, we would set the `argumentDefaults` option.  \n\n```js\nthis.commandHandler = new CommandHandler(this, {\n    directory: './commands/',\n    prefix: '?',\n    argumentDefaults: {\n        prompt: {\n            timeout: 'Time ran out, command has been cancelled.',\n            ended: 'Too many retries, command has been cancelled.',\n            cancel: 'Command has been cancelled.',\n            retries: 4,\n            time: 30000\n        }\n    }\n});\n```\n\nThose prompt options would now be applied to all prompts that do not have those options already.  \nOr, with a command with similar arguments:  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass AddCommand extends Command {\n    constructor() {\n        super('add', {\n            aliases: ['add'],\n            args: [\n                {\n                    id: 'numOne',\n                    type: 'number',\n                    prompt: true\n                },\n                {\n                    id: 'numTwo',\n                    type: 'number',\n                    prompt: true\n                }\n                {\n                    id: 'numThree',\n                    type: 'number',\n                    prompt: true\n                }\n            ],\n            defaultPrompt: {\n                start: 'Please input a number!',\n                retry: 'Please input a number!'\n            }\n        });\n    }\n\n    exec(message, args) {\n        const sum = args.numOne + args.numTwo + args.numThree;\n        return message.reply(`The sum is ${sum}!`);\n    }\n}\n\nmodule.exports = AddCommand;\n```\n\nRather than repeating the text for all three arguments, there is a default prompt that applies to all three.  \nTheir `prompt` property still has to be truthy in order to actually prompt, of course.  \n\n### Modifying\n\nPrompts can then be modified with a modify function.  \nIt is most useful inside the `argumentDefaults` option, such as on the command handler.  \n\n```js\nargumentDefaults: {\n    prompt: {\n        modifyStart: text => `${text}\\nType cancel to cancel this command.`,\n        modifyRetry: text => `${text}\\nType cancel to cancel this command.`,\n        timeout: 'Time ran out, command has been cancelled.',\n        ended: 'Too many retries, command has been cancelled.',\n        cancel: 'Command has been cancelled.',\n        retries: 4,\n        time: 30000\n    }\n}\n```\n\nThe options `modifyStart`, `modifyRetry`, etc. are used to modify those types of prompts.  \nWith the above options, all `start` and `retry` prompts will have \"Type cancel to cancel this command.\" appended after it.  \n","path":"docs/arguments/prompts.md"},"prompts2":{"name":"More Prompting","type":"md","content":"# More Prompting\n\n### Optional Prompts\n\nOptional prompts are prompts that run if there was input, but the type casting failed.  \nIf there was no input, it would go on as normal.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass HighestRoleCommand extends Command {\n    constructor() {\n        super('highestRole', {\n            aliases: ['highestRole'],\n            args: [\n                {\n                    id: 'member',\n                    type: 'member',\n                    prompt: {\n                        start: 'Who would you like to get the highest role of?',\n                        retry: 'That\\'s not a valid member! Try again.',\n                        optional: true\n                    },\n                    default: message => message.member\n                }\n            ],\n            channel: 'guild'\n        });\n    }\n\n    exec(message, args) {\n        return message.reply(args.member.highestRole.name);\n    }\n}\n\nmodule.exports = HighestRoleCommand;\n```\n\nWith it, `default` is now used again.  \n\n- `?highestRole` would give the name for the message author.\n- `?highestRole 1Computer` would give the name for 1Computer.\n- `?highestRole someone-non-existant` would start up the prompts.\n\n### Infinite Prompts\n\nInfinite prompts are prompts that go on and on until the user says stop.  \n(You can customize the input, but by default it is `stop`.)  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass PickCommand extends Command {\n    constructor() {\n        super('pick', {\n            aliases: ['pick'],\n            args: [\n                {\n                    id: 'items',\n                    match: 'none',\n                    prompt: {\n                        start: [\n                            'What items would you like to pick from?',\n                            'Type them in separate messages.',\n                            'Type `stop` when you are done.'\n                        ],\n                        infinite: true\n                    }\n                }\n            ]\n        });\n    }\n\n    exec(message, args) {\n        const picked = args.items[Math.floor(Math.random() * items.length)];\n        return message.reply(`I picked ${picked.trim()}!`);\n    }\n}\n\nmodule.exports = PickCommand;\n```\n\nAnd with that, `args.items` is now an array of responses from the user.  \nNote that the `none` match is used, meaning nothing is matched in the original message.  \nBecause this is an infinite prompt that goes across multiple messages, we don't want it to take input from the original message.  \nIf you wish to allow a hybrid of matching and prompting multiple phrases, try using `separate` match with infinite prompts.   \n","path":"docs/arguments/prompts2.md"},"unordered":{"name":"Unordered Arguments","type":"md","content":"# Unordered Arguments\n\n### Any Order!\n\nArguments can be made to be unordered.  \nFor example, if you want a command where the arguments are a role and a member in any order:  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass AddRoleCommand extends Command {\n    constructor() {\n        super('addrole', {\n            aliases: ['addrole'],\n            args: [\n                {\n                    id: 'member',\n                    type: 'member',\n                    unordered: true\n                },\n                {\n                    id: 'role',\n                    type: 'role',\n                    unordered: true\n                }\n            ],\n            userPermissions: ['ADMINISTRATOR'],\n            channel: 'guild'\n        });\n    }\n\n    async exec(message, args) {\n        await args.member.addRole(args.role);\n        return message.reply('Done!');\n    }\n}\n\nmodule.exports = AddRoleCommand;\n```\n\nThe above command would work as `!addrole member role` and `!addrole role member`.  \nNo phrase will be parsed twice, for example, if the first phrase matched as a member, the role argument will ignore the first phrase and start with the second.  \n\nOnly the match type `phrase` (which is by default) works with the `unordered` option.  \nOther match types will ignore this behavior.  \n\nTo choose a index to be unordered from (e.g. from the second phrase onwards) use a number, e.g. `unordered: 1`.  \nTo choose specific indices to be unordered on, use an array, e.g. `unordered: [0, 1, 2]`.  \n\n### With Defaults or Prompts\n\nUnordered arguments have a slightly different behavior when used with a default value and/or a prompt.  \n\nIf an unordered argument has a default and nothing matches, the default is used.  \nIf there is a prompt and nothing matches:  \n  - If the prompt is optional, the default value is used.  \n  - If not, the prompt is started as if no input was given.  \n\nSo, if you do have a prompt, make sure the `optional` option is not used or else it will prompt not at all.  \n","path":"docs/arguments/unordered.md"},"generators":{"name":"Generator Arguments","type":"md","content":"# Generator Arguments\n\n## Yield!\n\nThe most powerful aspect of Akairo's argument parsing is the fact that it is implemented using generators.  \nWith this, you can do things such as:\n- Have an argument depend on the previous argument\n- Branch your argument parsing\n- Run an argument multiple times\n- Inject code in between arguments\n- And more!\n\nTo get started, take this command:  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass GeneratorCommand extends Command {\n    constructor() {\n        super('generator', {\n            aliases: ['generator']\n        });\n    }\n\n    *args() {\n        // Here!\n    }\n\n    exec(message, args) {\n        // Do whatever.\n    }\n}\n\nmodule.exports = GeneratorCommand;\n```\n\nNote that instead of an `args` object in the `super` call, we have a generator method, `*args`.  \nWe will focus on this method.  \n(You can put it in the `super` call if you want, but it is cleaner this way.)  \n\nTo run an argument:  \n\n```js\n*args() {\n    // Notice: no `id` necessary!\n    // Also notice: `yield` must be used.\n    const x = yield { type: 'integer' };\n    const y = yield {\n        type: 'integer',\n        prompt: {\n            // Everything you know still works.\n        }\n    };\n\n    // When finished.\n    return { x, y };\n}\n```\n\nBut more things are possible because you have access to all of JavaScript's syntax!  \n\n```js\n*args(message) {\n    const x = yield { type: 'integer' };\n\n    // Use previous arguments by referring to the identifier.\n    const y = yield (x > 10 ? { type: 'integer' } : { type: 'string' });\n\n    // Debug in between your arguments!\n    console.log('debug', message.id, x, y);\n\n    return { x, y };\n}\n```\n","path":"docs/arguments/generators.md"}}},"inhibitors":{"name":"Inhibitors","files":{"inhibtypes":{"name":"Inhibitor Types","type":"md","content":"# Inhibitor Types\n\n### More Coverage\n\nRight now, your inhibitors only runs before a command.  \nThey does not actually run on all messages.  \n\nTo change that, change the `type` option.  \n\n```js\nconst { Inhibitor } = require('discord-akairo');\n\nclass BlacklistInhibitor extends Inhibitor {\n    constructor() {\n        super('blacklist', {\n            reason: 'blacklist',\n            type: 'all'\n        });\n    }\n\n    exec(message) {\n        // Still a meanie!\n        const blacklist = ['81440962496172032'];\n        return blacklist.includes(message.author.id);\n    }\n}\n\nmodule.exports = BlacklistInhibitor;\n```\n\nThere are three types:  \n\n- `all` is run on all messages.\n- `pre` is run on messages not blocked by `all` and built-in inhibitors.\n- `post` (the default) is run on messages before commands, not blocked by the previous.\n\nThe built-in inhibitors are:  \n\n- `client` blocks the client (itself).\n- `bot` blocks all other bots.\n- `owner` blocks non-owners from using owner-only commands.\n- `guild` blocks guild-only commands used in DMs.\n- `dm` blocks DM-only commands used in guilds.\n\nTo make it easier to visualize, here is the order:  \n\n- `all` type inhibitors.\n- `client`, and `bot`.\n- (commands sent when someone is in the middle of being prompted are blocked here)\n- `pre` type inhibitors.\n- `owner`, `guild`, and `dm`.\n- (commands that have missing permissions are blocked here)\n- `post` type inhibitors.\n- (commands under cooldown are blocked here)\n","path":"docs/inhibitors/inhibtypes.md"},"priority":{"name":"Inhibitor Priority","type":"md","content":"# Inhibitor Priority\n\n### Me First!\n\nSometimes multiple inhibitors can block a message.  \nFor example, you may have an inhibitor for blacklisting within a server, and another for a global blacklist.  \nBy default, inhibitors are ordered by their load order, which is based on the filename.  \nSo, if you had named the inhibitors `blacklist.js` and `globalBlacklist.js`, the former would have a higher priority.  \nWhenever both inhibitors block a message, the `commandBlocked` event would fire with the blacklist inhibitor's reason.  \nIf you want the global blacklist inhibitor's instead you can use the `priority` option.  \n\n```js\nconst { Inhibitor } = require('discord-akairo');\nconst globalBlacklist = require('something');\n\nclass GlobalBlacklistInhibitor extends Inhibitor {\n    constructor() {\n        super('globalBlacklist', {\n            reason: 'globalBlacklist',\n            priority: 1\n        });\n    }\n\n    exec(message) {\n        return globalBlacklist.has(message.author.id);\n    }\n}\n\nmodule.exports = BlacklistInhibitor;\n```\n\nBy default, inhibitors have a priority of 0.  \nBy increasing it, it means that the inhibitor will now have priority over the others.  \nSo when two inhibitors block a message, the one with the higher priority will be used.  \nIf they have the same priority, then it is still by load order.  \n","path":"docs/inhibitors/priority.md"}}},"listeners":{"name":"Listeners","files":{"emitters":{"name":"Custom Emitters","type":"md","content":"# Custom Emitters\n\n### Watching Process\n\nAs shown in the first listener tutorial, we can have custom emitters.  \nListeners can run on more than Akairo-related things.  \nTo add a custom emitter, use the `setEmitters` method available on the listener handler.  \n\n```js\nthis.listenerHandler.setEmitters({\n    process: process,\n    anything: youWant\n});\n```\n\nThe key will be the emitter's name, and the value is the emitter itself.  \nNow, we can use a listener on the process:  \n\n```js\nconst { Listener } = require('discord-akairo');\n\nclass UnhandledRejectionListener extends Listener {\n    constructor() {\n        super('unhandledRejection', {\n            event: 'unhandledRejection',\n            emitter: 'process'\n        });\n    }\n\n    exec(error) {\n        console.error(error);\n    }\n}\n\nmodule.exports = UnhandledRejectionListener;\n```\n","path":"docs/listeners/emitters.md"}}},"other":{"name":"Other","files":{"updating":{"name":"Updating to v8","type":"md","content":"# Updating to v8\n\n### Breaking Changes\n\nThis tutorial is for updating from Akairo v7 to v8.  \nMany changes were introduced in v8 so hopefully this guide can help you fix them.  \n\nNot only are there changes within the framework, there are also changes with Discord.js v12.  \nYou will have to update to Node 10 in order to use the libraries due to new JavaScript features.  \n\nThe suggestions below are not an exhaustive list.  \nFor a full changelog, see [here](https://github.com/discord-akairo/discord-akairo/releases).  \n\n### Renames\n\nBelow are renames that will mostly be find-and-replace.  \n\n##### General \n\nThe ClientUtil method `fetchMemberFrom` has been renamed to `fetchMember`.  \n\n##### Commands\n\nThe CommandHandler event `commandCooldown` has been renamed to `cooldown`.  \n\nThe Command option and property `channelRestriction` has been renamed to just `channel`.  \nThe Command option and property `trigger` has been renamed to `regex`.  \n\n##### Arguments\n\nThe Argument option and property `prefix` has been renamed to `flag`.  \nThe Argument method `cast` has been renamed to `process`.  \n\nRegex types in arguments e.g. `type: /^text$/` used to evaluate to an object with the property `match` and `groups`.  \nThis has been replaced with an object with the property `match` and `matches`.  \n\nThe match type `word` has been renamed to `phrase`.  \nThe match type `prefix` has been renamed to `option`.  \n\nThe TypeResolver property `handler` has been renamed to `commandHandler`.  \n\n##### Listeners\n\nThe Listener option and property `eventName` has been renamed to just `event`.  \n\n### Changes\n\nBelow are breaking changes that may require some more thought when fixing.  \n\n##### General\n\nThe structure of the AkairoClient and the various handlers has been changed.  \nTo see what has changed, start at [Setting Up](../basics/setup.md).  \n\nBefore, in a type function of an arg when returning a Promise, it would only be a cast failure if the Promise rejected.  \nNow, it will only be cast failure if the Promise resolves with `null` or `undefined`.  \nThis is to make async functions easier to use.  \n\nSimilarly, in inhibitors, a Promise rejection would be used to signify that the message was to be blocked.  \nNow, with Promises, the Promise has to resolve with `true` to signify a block.  \n\nThe following methods are now properties:  \n\n- `Argument#default`\n- `Command#trigger`\n- `CommandHandler#prefix`\n- `CommandHandler#allowMention`\n\nThis means that you have to check if its a function before using it e.g.  \n`typeof arg.default === 'function' ? arg.default(message) : arg.default`.  \nThis allows for checking if a value was set, such as the default value of an argument.  \nOf course, if you already know that the property is or is not a function, then there is no need for changes.  \n\n##### Commands\n\nThe events `commandStarted` and `commandFinished` have new parameters.  \n`commandStarted` now passes `(message, command, args)` where `args` are the parsed args.  \n`commandFinished` now passes `(message, command, args, returnValue)` where `returnValue` is what the command's exec function returned.  \n\nThe event `commandBlocked` is no longer fired when permissions checks are failed.  \nInstead, a new event `missingPermissions` is fired.  \nIt will have the params `(message, command, type, missing)` where `type` could be either `client` or `user` and `missing` are the missing permissions.  \n\nRegex commands used to pass in the values of `(message, match, groups, edited)`.  \nNow it has been changed to `(message, args)`.  \nThe `args` object will contain `match` and `matches` property similar to a regex type.  \n\nCommandHandler options `handleEdits` will no longer implicitly enable the `commandUtil` option.  \nThe `commandUtilLifetime` option also now defaults to 5 minutes.  \n\nAll the CommandUtil parse information such as `command`, `prefix`, `alias` etc. are moved to the `parsed` property.  \n\nThe `defaultPrompt` option has been changed to `argumentDefaults` which allow for more defaults.  \nYou can simply move your options into `argumentDefaults.prompt`.  \n\n##### Arguments\n\nArgument parsing now uses a new parser.  \nSome behavior with whitespace and quotes may have changed.  \n\nThe argument type function used to have a special behavior for when `true` was returned.  \nIt would use the original user input phrase as the evaluated argument.  \nNow, it simply is just `true`.  \n\nArgument functions `this` binding has also been changed.  \nThey will now all point to the Argument instance rather than being inconsistent, where some would point to the command.  \n\nThe default value of the argument `default` option is now `null` rather than an empty string.  \n\nType functions previously would be passed `(phrase, message, args)`.  \nThey now pass `(message, phrase)`.  \nThe previous arguments can be accessed by using a generator for arguments.  \n\nPreviously, prompt functions would be passed `(message, args, retries)`.  \nThey now pass `(message, data)` where `data` is an object.  \nYou can get the retry count, among other properties, with `data.retries`.  \nThe previous arguments can be accessed by using a generator for arguments.  \n\nThe argument type `invite` used to just match an invite from a string.  \nNow, it will attempt to fetch an Invite object.  \n\n### Removals\n\nAll features deprecated in v7.5.x have been removed as well as some unexpected removals.  \nSuggestions will be made for replacements.  \n\n##### General\n\nLoading modules by instances is now unsupported.  \nThis means you cannot do, for example, `module.exports = new Command(...)` or `handler.load(new Listener(...))`.  \nSubsequently, this also means that the constructor for AkairoModule and related have also changed.  \nThe constructor is now `(id, options)` instead of `(id, exec, options)`.  \nThe `exec` method is now also not on the AkairoModule prototype and should be implemented where needed when extending.  \n\nThe AkairoHandler method `add` has been removed.  \nUse the `load` with a full path instead.  \n\nThe AkairoHandler events `add` and `reload` have been removed.  \nThe `load` event will now take care of both.  \nWhen reloaded, the `load` event will pass a second parameter which is a boolean, signifying that is was a reload.  \n\nThe ability to enable/disable modules have been removed, along with the events.  \nIt is recommended to implement this feature manually instead.  \n\nBoth ClientUtil prompt methods, `prompt` and `promptIn` were removed.  \nAlternatives includes your own message collector, using `awaitMessages`, or using `Argument#collect`.  \nAn example of the `collect` method would be `new Argument(command, argOptions).collect(message)`.  \n\nSelfbot support has been removed.  \n\n##### Commands\n\nThe command option `split` is now removed.  \nInstead, the `quoted` option is added, which can be true or false, defaulting to true.  \n\nThe `match` option on an argument can no longer be a function.  \n\nIn the command `exec` function as well as the `commandStarted` event and some other places, the `edited` parameter is removed.  \nTo see if the message was edited, you can check with `message.edited`.    \n\nThe `dynamic` and `dynamicInt` types were removed.  \nInstead, use a union type e.g. `Argument.union('integer', 'string')`.  \n\n##### SQLiteHandler\n\nSQLiteHandler and related properties in AkairoClient have been removed completely.  \nAlternatives include `SQLiteProvider` and `SequelizeProvider`.  \nOr, you can make your own by extending the `Provider` class.  \nFor a guide on how to use the new providers, see [Using Providers](./providers,md).  \n\n##### Other Removals\n\nOther removals include the send aliases in CommandUtil, deprecated methods in ClientUtil, and some methods in AkairoClient.  \nMost of them can now be found in Discord.js itself or implemented yourself if needed.  \n","path":"docs/other/updating.md"},"handling":{"name":"Handling Modules","type":"md","content":"# Handling Modules\n\n### Categorizing\n\nYou can categorize a module with the `category` option.  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass PingCommand extends Command {\n    constructor() {\n        super('ping', {\n            aliases: ['ping'],\n            category: 'stuff'\n        });\n    }\n\n    exec(message) {\n        return message.reply('Pong!');\n    }\n}\n\nmodule.exports = PingCommand;\n```\n\nA new category will be created on the handler with the ID of `stuff`.  \nBy default, all modules are in the `default` category.  \n\n### Reloading\n\nEverything in Akairo is a module, and all modules are loaded by handlers.  \nWith that said, this means you can add, remove, or reload modules while the bot is running!  \n\nHere is a basic command that reloads the inputted ID:  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass ReloadCommand extends Command {\n    constructor() {\n        super('reload', {\n            aliases: ['reload'],\n            args: [\n                {\n                    id: 'commandID'\n                }\n            ],\n            ownerOnly: true,\n            category: 'owner'\n        });\n    }\n\n    exec(message, args) {\n        // `this` refers to the command object.\n        this.handler.reload(args.commandID);\n        return message.reply(`Reloaded command ${args.commandID}!`);\n    }\n}\n\nmodule.exports = ReloadCommand;\n```\n\nWays you can reload a module includes:  \n\n- Individually:\n    - `<AkairoHandler>.reload(moduleID)`\n    - `<AkairoModule>.reload()`\n- Many at once:\n    - `<AkairoHandler>.reloadAll()`\n    - `<Category>.reloadAll()`\n\n### Removing and Adding\n\nFor removing, simply change all those `reload` to `remove`.  \nTo add a new module, you can use the `load` method.  \nWith `load`, you will need to specify a full filepath or a module class.  \nIf you load with a class, note that those cannot be reloaded.  \n","path":"docs/other/handling.md"},"handlers":{"name":"Custom Handlers","type":"md","content":"# Custom Handlers\n\n### And Custom Modules\n\nInternally, Akairo's handlers all extends AkairoHandler, and all modules extends AkairoModule.  \nSo, you can create your own handlers and module types!  \nCreate a new class for your module.  \n\n```js\nconst { AkairoModule } = require('discord-akairo');\n\nclass CustomModule extends AkairoModule {\n    constructor(id, options = {}) {\n        super(id, options);\n\n        this.color = options.color || 'red';\n    }\n\n    exec() {\n        throw new Error('Not implemented!');\n    }\n}\n\nmodule.exports = CustomModule;\n```\n\nNote that the `exec` method you see in Command, Inhibitor, and Listener are not native to AkairoModule.  \nThey require you to actually create them within the module type, such as above.  \nWe throw an error there just in case you forget to implement it.  \n\nThen, create a new class for your handler:  \n\n```js\nconst { AkairoHandler } = require('discord-akairo');\nconst CustomModule = require('./CustomModule');\n\nclass CustomHandler extends AkairoHandler {\n    constructor(client, options = {}) {\n        super(client, {\n            directory: options.directory,\n            classToHandle: CustomModule\n        });\n\n        this.customOption = options.customOption || 'something';\n    }\n}\n\nmodule.exports = CustomHandler;\n```\n\nFor the handler, the `super()` takes the client, the directory for the handler, and the class of the module type we want to handle.  \nNow we can add it to our client if we so desire:  \n\n```js\nconst { AkairoClient } = require('discord-akairo');\nconst CustomHandler = require('./CustomHandler');\n\nclass MyClient extends AkairoClient {\n    constructor() {\n        super({\n            ownerID: '123992700587343872',\n        }, {\n            disableEveryone: true\n        });\n\n        this.customHandler = new CustomHandler(this, {\n            directory: './customs/'\n        });\n\n        this.customHandler.loadAll();\n    }\n}\n\nmodule.exports = MyClient;\n```\n\nAnd the module:  \n\n```js\nconst CustomModule = require('../CustomModule');\n\nclass CustomCustom extends CustomModule {\n    constructor() {\n        super('custom', {\n            color: 'blue'\n        });\n    }\n\n    exec() {\n        console.log('I did something!');\n    }\n}\n\nmodule.exports = CustomCustom;\n```\n\nCustom handlers and modules are can get much more complicated than this.  \nHowever, it would be out of the scope of this tutorial, so if you want to go there, check out the source code on Github.  \n","path":"docs/other/handlers.md"},"providers":{"name":"Using Providers","type":"md","content":"# Using Providers\n\n### Storing Prefixes\n\nAkairo comes with SQLiteProvider and SequelizeProvider, optional utility classes for databases.  \nNote that if you are doing something complicated with databases, you should use SQLite or Sequelize directly.  \n\nLet's implement per-guild prefixes.  \nFirst, create a new SQLiteProvider or SequelizeProvider.  \n\n```js\nconst sqlite = require('sqlite');\nconst sequelize = require('sequelize');\n\nconst { AkairoClient, SQLiteProvider, SequelizeProvider } = require('discord-akairo');\n\nclass CustomClient extends AkairoClient {\n    constructor() {\n        super({\n            /* Options here */\n        });\n\n        // With SQLite\n        this.settings = new SQLiteProvider(sqlite.open('path/to/db.sqlite'), 'table_name', {\n            idColumn: 'guild_id',\n            dataColumn: 'settings'\n        });\n\n        // Or, with sequelize\n        this.settings = new SequelizeProvider(/* Sequelize model here */, {\n            idColumn: 'guild_id',\n            dataColumn: 'settings'\n        });\n    }\n}\n```\n\nThe providers only handle one table at a time.  \nNotice that you can set the `idColumn` and the `dataColumn`.  \n\nThe `idColumn` defaults to `id` and is the unique key for that table.  \nThe `dataColumn` is optional and will change the behavior of the provider in relation with the database.  \n\nWhen the `dataColumn` is provided, the provider will parse a single column as JSON in order to set values.  \nFor Sequelize, remember to set that column's type to JSON or JSONB.  \n\nWhen `dataColumn` is not provided, the provider will work on all columns of the table instead.  \n\nBefore you can actually use the provider, you would have to run the `init` method.  \nFor example:  \n\n```js\nclass CustomClient extends AkairoClient {\n    /* ... */\n    async login(token) {\n        await this.settings.init()\n        return super.login(token);\n    }\n}\n```\n\nNow, the provider can be used like so:  \n\n```js\nclass CustomClient extends AkairoClient {\n    constructor() {\n        super({\n            prefix: message => {\n                if (message.guild) {\n                    // The third param is the default.\n                    return this.settings.get(message.guild.id, 'prefix', '!');\n                }\n\n                return '!';\n            }\n        });\n\n        /* ... */\n    }\n}\n```\n\nValues can be set with the `set` method:  \n\n```js\nconst { Command } = require('discord-akairo');\n\nclass PrefixCommand extends Command {\n    constructor() {\n        super('prefix', {\n            aliases: ['prefix'],\n            category: 'stuff',\n            args: [\n                {\n                    id: 'prefix',\n                    default: '!'\n                }\n            ],\n            channel: 'guild'\n        });\n    }\n\n    async exec(message, args) {\n        // The third param is the default.\n        const oldPrefix = this.client.settings.get(message.guild.id, 'prefix', '!');\n\n        await this.client.settings.set(message.guild.id, 'prefix', args.prefix);\n        return message.reply(`Prefix changed from ${oldPrefix} to ${args.prefix}`);\n    }\n}\n\nmodule.exports = PrefixCommand;\n```\n","path":"docs/other/providers.md"},"clientutil":{"name":"ClientUtil","type":"md","content":"# ClientUtil\n\n### Finding Things\n\nClientUtil is a class filled with utility methods.  \nIt is available on your client as `client.util`.  \n\nThere are three \"groups\" of resolver methods for finding or checking Discord-related things.  \nThey allow you to, for example, find a user named `1Computer` from an input of `comp`.  \n\n- `resolve <thing>`\n    - e.g. `resolveUser`, `resolveChannel`, etc.\n    - Finds an Discord-related object from a collection of those objects.\n\n- `resolve <things>`\n    - e.g. `resolveUsers`, `resolveChannels`, etc.\n    - Filters Discord-related objects from a collection of those objects.\n\n- `check <thing>`\n    - e.g. `checkUser`, `checkChannel`, etc.\n    - Used for the above methods, checks if a string could be referring to the object.\n\n### Other Methods\n\nThere are a bunch of other things you may find useful:  \n\n- `embed`, `attachment`, and `collection`\n    - Shortcuts for MessageEmbed, MessageAttachment, and Collection.\n- `resolvePermissionNumber`\n    - Converts a permission number to an array of permission names.\n","path":"docs/other/clientutil.md"}}},"snippets":{"name":"Snippets","files":{"ping":{"name":"Ping Command","type":"md","content":"# Ping Command\n\n```js\nconst { Command } = require('discord-akairo');\n\nclass PingCommand extends Command {\n    constructor() {\n        super('ping', {\n            aliases: ['ping', 'hello']\n        });\n    }\n\n    async exec(message) {\n        const sent = await message.util.reply('Pong!');\n        const timeDiff = (sent.editedAt || sent.createdAt) - (message.editedAt || message.createdAt);\n        return message.util.reply([\n            'Pong!',\n            `🔂 **RTT**: ${timeDiff} ms`,\n            `💟 **Heartbeat**: ${Math.round(this.client.ping)} ms`\n        ]);\n    }\n}\n\nmodule.exports = PingCommand;\n```\n","path":"docs/snippets/ping.md"}}}},"classes":[{"name":"Provider","description":"A provider for key-value storage.\nMust be implemented.","props":[{"name":"items","description":"Cached entries.","type":[[["Collection","<"],["string",", "],["Object",">"]]],"meta":{"line":14,"file":"Provider.js","path":"src/providers"}}],"methods":[{"name":"init","description":"Initializes the provider.","abstract":true,"returns":[[["any"]]],"meta":{"line":22,"file":"Provider.js","path":"src/providers"}},{"name":"get","description":"Gets a value.","abstract":true,"params":[{"name":"id","description":"ID of entry.","type":[[["string"]]]},{"name":"key","description":"The key to get.","type":[[["string"]]]},{"name":"defaultValue","description":"Default value if not found or null.","optional":true,"type":[[["any"]]]}],"returns":[[["any"]]],"meta":{"line":34,"file":"Provider.js","path":"src/providers"}},{"name":"set","description":"Sets a value.","abstract":true,"params":[{"name":"id","description":"ID of entry.","type":[[["string"]]]},{"name":"key","description":"The key to set.","type":[[["string"]]]},{"name":"value","description":"The value.","type":[[["any"]]]}],"returns":[[["any"]]],"meta":{"line":46,"file":"Provider.js","path":"src/providers"}},{"name":"delete","description":"Deletes a value.","abstract":true,"params":[{"name":"id","description":"ID of entry.","type":[[["string"]]]},{"name":"key","description":"The key to delete.","type":[[["string"]]]}],"returns":[[["any"]]],"meta":{"line":57,"file":"Provider.js","path":"src/providers"}},{"name":"clear","description":"Clears an entry.","abstract":true,"params":[{"name":"id","description":"ID of entry.","type":[[["string"]]]}],"returns":[[["any"]]],"meta":{"line":67,"file":"Provider.js","path":"src/providers"}}],"meta":{"line":8,"file":"Provider.js","path":"src/providers"}},{"name":"SequelizeProvider","description":"Provider using the `sequelize` library.","extends":["Provider"],"construct":{"name":"SequelizeProvider","params":[{"name":"table","description":"A Sequelize model.","type":[[["Model"]]]},{"name":"options","description":"Options to use.","optional":true,"default":"{}","type":[[["ProviderOptions"]]]}]},"props":[{"name":"table","description":"Sequelize model.","type":[[["Model"]]],"meta":{"line":17,"file":"SequelizeProvider.js","path":"src/providers"}},{"name":"idColumn","description":"Column for ID.","type":[[["string"]]],"meta":{"line":23,"file":"SequelizeProvider.js","path":"src/providers"}},{"name":"dataColumn","description":"Column for JSON data.","nullable":true,"type":[[["string"]]],"meta":{"line":29,"file":"SequelizeProvider.js","path":"src/providers"}},{"name":"items","description":"Cached entries.","type":[[["Collection","<"],["string",", "],["Object",">"]]],"meta":{"line":14,"file":"Provider.js","path":"src/providers"}}],"methods":[{"name":"init","description":"Initializes the provider.","async":true,"returns":[[["Bluebird","<"],["void",">"]]],"meta":{"line":36,"file":"SequelizeProvider.js","path":"src/providers"}},{"name":"get","description":"Gets a value.","params":[{"name":"id","description":"ID of entry.","type":[[["string"]]]},{"name":"key","description":"The key to get.","type":[[["string"]]]},{"name":"defaultValue","description":"Default value if not found or null.","optional":true,"type":[[["any"]]]}],"returns":[[["any"]]],"meta":{"line":50,"file":"SequelizeProvider.js","path":"src/providers"}},{"name":"set","description":"Sets a value.","params":[{"name":"id","description":"ID of entry.","type":[[["string"]]]},{"name":"key","description":"The key to set.","type":[[["string"]]]},{"name":"value","description":"The value.","type":[[["any"]]]}],"returns":[[["Bluebird","<"],["boolean",">"]]],"meta":{"line":66,"file":"SequelizeProvider.js","path":"src/providers"}},{"name":"delete","description":"Deletes a value.","params":[{"name":"id","description":"ID of entry.","type":[[["string"]]]},{"name":"key","description":"The key to delete.","type":[[["string"]]]}],"returns":[[["Bluebird","<"],["boolean",">"]]],"meta":{"line":90,"file":"SequelizeProvider.js","path":"src/providers"}},{"name":"clear","description":"Clears an entry.","params":[{"name":"id","description":"ID of entry.","type":[[["string"]]]}],"returns":[[["Bluebird","<"],["void",">"]]],"meta":{"line":112,"file":"SequelizeProvider.js","path":"src/providers"}}],"meta":{"line":9,"file":"SequelizeProvider.js","path":"src/providers"}},{"name":"SQLiteProvider","description":"Provider using the `sqlite` library.","extends":["Provider"],"construct":{"name":"SQLiteProvider","params":[{"name":"db","description":"SQLite database from `sqlite`.","type":[[["Database"]],[["Promise","<"],["Database",">"]]]},{"name":"tableName","description":"Name of table to handle.","type":[[["string"]]]},{"name":"options","description":"Options to use.","optional":true,"default":"{}","type":[[["ProviderOptions"]]]}]},"props":[{"name":"db","description":"SQLite database.","type":[[["Database"]]],"meta":{"line":18,"file":"SQLiteProvider.js","path":"src/providers"}},{"name":"tableName","description":"Name of the table.","type":[[["string"]]],"meta":{"line":24,"file":"SQLiteProvider.js","path":"src/providers"}},{"name":"idColumn","description":"Column for ID.","type":[[["string"]]],"meta":{"line":30,"file":"SQLiteProvider.js","path":"src/providers"}},{"name":"dataColumn","description":"Column for JSON data.","nullable":true,"type":[[["string"]]],"meta":{"line":36,"file":"SQLiteProvider.js","path":"src/providers"}},{"name":"items","description":"Cached entries.","type":[[["Collection","<"],["string",", "],["Object",">"]]],"meta":{"line":14,"file":"Provider.js","path":"src/providers"}}],"methods":[{"name":"init","description":"Initializes the provider.","async":true,"returns":[[["Promise","<"],["void",">"]]],"meta":{"line":43,"file":"SQLiteProvider.js","path":"src/providers"}},{"name":"get","description":"Gets a value.","params":[{"name":"id","description":"ID of entry.","type":[[["string"]]]},{"name":"key","description":"The key to get.","type":[[["string"]]]},{"name":"defaultValue","description":"Default value if not found or null.","optional":true,"type":[[["any"]]]}],"returns":[[["any"]]],"meta":{"line":60,"file":"SQLiteProvider.js","path":"src/providers"}},{"name":"set","description":"Sets a value.","params":[{"name":"id","description":"ID of entry.","type":[[["string"]]]},{"name":"key","description":"The key to set.","type":[[["string"]]]},{"name":"value","description":"The value.","type":[[["any"]]]}],"returns":[[["Promise","<"],["Statement",">"]]],"meta":{"line":76,"file":"SQLiteProvider.js","path":"src/providers"}},{"name":"delete","description":"Deletes a value.","params":[{"name":"id","description":"ID of entry.","type":[[["string"]]]},{"name":"key","description":"The key to delete.","type":[[["string"]]]}],"returns":[[["Promise","<"],["Statement",">"]]],"meta":{"line":106,"file":"SQLiteProvider.js","path":"src/providers"}},{"name":"clear","description":"Clears an entry.","params":[{"name":"id","description":"ID of entry.","type":[[["string"]]]}],"returns":[[["Promise","<"],["Statement",">"]]],"meta":{"line":128,"file":"SQLiteProvider.js","path":"src/providers"}}],"meta":{"line":10,"file":"SQLiteProvider.js","path":"src/providers"}},{"name":"AkairoClient","description":"The Akairo framework client.\nCreates the handlers and sets them up.","construct":{"name":"AkairoClient","params":[{"name":"options","description":"Options for the client.","optional":true,"default":"{}","type":[[["AkairoOptions"]]]},{"name":"clientOptions","description":"Options for Discord JS client.\nIf not specified, the previous options parameter is used instead.","optional":true,"type":[[["ClientOptions"]]]}]},"props":[{"name":"ownerID","description":"The ID of the owner(s).","type":[[["Snowflake"]],[["Array","<"],["Snowflake",">"]]],"meta":{"line":21,"file":"AkairoClient.js","path":"src/struct"}},{"name":"util","description":"Utility methods.","type":[[["ClientUtil"]]],"meta":{"line":27,"file":"AkairoClient.js","path":"src/struct"}}],"methods":[{"name":"isOwner","description":"Checks if a user is the owner of this bot.","params":[{"name":"user","description":"User to check.","type":[[["UserResolvable"]]]}],"returns":[[["boolean"]]],"meta":{"line":35,"file":"AkairoClient.js","path":"src/struct"}}],"meta":{"line":11,"file":"AkairoClient.js","path":"src/struct"}},{"name":"AkairoHandler","description":"Base class for handling modules.","extends":["EventEmitter"],"construct":{"name":"AkairoHandler","params":[{"name":"client","description":"The Akairo client.","type":[[["AkairoClient"]]]},{"name":"options","description":"Options for module loading and handling.","type":[[["AkairoHandlerOptions"]]]}]},"props":[{"name":"client","description":"The Akairo client.","type":[[["AkairoClient"]]],"meta":{"line":30,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"directory","description":"The main directory to modules.","type":[[["string"]]],"meta":{"line":36,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"classToHandle","description":"Class to handle.","type":[[["function"]]],"meta":{"line":42,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"extensions","description":"File extensions to load.","type":[[["Set","<"],["string",">"]]],"meta":{"line":48,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"automateCategories","description":"Whether or not to automate category names.","type":[[["boolean"]]],"meta":{"line":54,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"loadFilter","description":"Function that filters files when loading.","type":[[["LoadPredicate"]]],"meta":{"line":60,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"modules","description":"Modules loaded, mapped by ID to AkairoModule.","type":[[["Collection","<"],["string",", "],["AkairoModule",">"]]],"meta":{"line":66,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"categories","description":"Categories, mapped by ID to Category.","type":[[["Collection","<"],["string",", "],["Category",">"]]],"meta":{"line":72,"file":"AkairoHandler.js","path":"src/struct"}}],"methods":[{"name":"register","description":"Registers a module.","params":[{"name":"mod","description":"Module to use.","type":[[["AkairoModule"]]]},{"name":"filepath","description":"Filepath of module.","optional":true,"type":[[["string"]]]}],"returns":[[["void"]]],"meta":{"line":81,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"deregister","description":"Deregisters a module.","params":[{"name":"mod","description":"Module to use.","type":[[["AkairoModule"]]]}],"returns":[[["void"]]],"meta":{"line":106,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"load","description":"Loads a module, can be a module class or a filepath.","params":[{"name":"thing","description":"Module class or path to module.","type":[[["string"]],[["function"]]]},{"name":"isReload","description":"Whether this is a reload or not.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["AkairoModule"]]],"meta":{"line":118,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"loadAll","description":"Reads all modules from a directory and loads them.","params":[{"name":"directory","description":"Directory to load from.\nDefaults to the directory passed in the constructor.","optional":true,"type":[[["string"]]]},{"name":"filter","description":"Filter for files, where true means it should be loaded.\nDefaults to the filter passed in the constructor.","optional":true,"type":[[["LoadPredicate"]]]}],"returns":[[["AkairoHandler"]]],"meta":{"line":152,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"remove","description":"Removes a module.","params":[{"name":"id","description":"ID of the module.","type":[[["string"]]]}],"returns":[[["AkairoModule"]]],"meta":{"line":167,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"removeAll","description":"Removes all modules.","returns":[[["AkairoHandler"]]],"meta":{"line":181,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"reload","description":"Reloads a module.","params":[{"name":"id","description":"ID of the module.","type":[[["string"]]]}],"returns":[[["AkairoModule"]]],"meta":{"line":194,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"reloadAll","description":"Reloads all modules.","returns":[[["AkairoHandler"]]],"meta":{"line":210,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"findCategory","description":"Finds a category by name.","params":[{"name":"name","description":"Name to find with.","type":[[["string"]]]}],"returns":[[["Category"]]],"meta":{"line":223,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"readdirRecursive","description":"Reads files recursively from a directory.","scope":"static","params":[{"name":"directory","description":"Directory to read.","type":[[["string"]]]}],"returns":[[["Array","<"],["string",">"]]],"meta":{"line":234,"file":"AkairoHandler.js","path":"src/struct"}}],"events":[{"name":"load","description":"Emitted when a module is loaded.","params":[{"name":"mod","description":"Module loaded.","type":[[["AkairoModule"]]]},{"name":"isReload","description":"Whether or not this was a reload.","type":[[["boolean"]]]}],"meta":{"line":257,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"remove","description":"Emitted when a module is removed.","params":[{"name":"mod","description":"Module removed.","type":[[["AkairoModule"]]]}],"meta":{"line":264,"file":"AkairoHandler.js","path":"src/struct"}}],"meta":{"line":16,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"AkairoModule","description":"Base class for a module.","construct":{"name":"AkairoModule","params":[{"name":"id","description":"ID of module.","type":[[["string"]]]},{"name":"options","description":"Options.","optional":true,"default":"{}","type":[[["AkairoModuleOptions"]]]}]},"props":[{"name":"id","description":"ID of the module.","type":[[["string"]]],"meta":{"line":12,"file":"AkairoModule.js","path":"src/struct"}},{"name":"categoryID","description":"ID of the category this belongs to.","type":[[["string"]]],"meta":{"line":18,"file":"AkairoModule.js","path":"src/struct"}},{"name":"category","description":"Category this belongs to.","type":[[["Category"]]],"meta":{"line":24,"file":"AkairoModule.js","path":"src/struct"}},{"name":"filepath","description":"The filepath.","type":[[["string"]]],"meta":{"line":30,"file":"AkairoModule.js","path":"src/struct"}},{"name":"client","description":"The Akairo client.","type":[[["AkairoClient"]]],"meta":{"line":36,"file":"AkairoModule.js","path":"src/struct"}},{"name":"handler","description":"The handler.","type":[[["AkairoHandler"]]],"meta":{"line":42,"file":"AkairoModule.js","path":"src/struct"}}],"methods":[{"name":"reload","description":"Reloads the module.","returns":[[["AkairoModule"]]],"meta":{"line":49,"file":"AkairoModule.js","path":"src/struct"}},{"name":"remove","description":"Removes the module.","returns":[[["AkairoModule"]]],"meta":{"line":57,"file":"AkairoModule.js","path":"src/struct"}},{"name":"toString","description":"Returns the ID.","returns":[[["string"]]],"meta":{"line":65,"file":"AkairoModule.js","path":"src/struct"}}],"meta":{"line":6,"file":"AkairoModule.js","path":"src/struct"}},{"name":"ClientUtil","description":"Client utilities to help with common tasks.","construct":{"name":"ClientUtil","params":[{"name":"client","description":"The client.","type":[[["AkairoClient"]]]}]},"props":[{"name":"client","description":"The Akairo client.","type":[[["AkairoClient"]]],"meta":{"line":13,"file":"ClientUtil.js","path":"src/struct"}}],"methods":[{"name":"resolveUser","description":"Resolves a user from a string, such as an ID, a name, or a mention.","params":[{"name":"text","description":"Text to resolve.","type":[[["string"]]]},{"name":"users","description":"Collection of users to find in.","type":[[["Collection","<"],["Snowflake",", "],["User",">"]]]},{"name":"caseSensitive","description":"Makes finding by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes finding by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["User"]]],"meta":{"line":24,"file":"ClientUtil.js","path":"src/struct"}},{"name":"resolveUsers","description":"Resolves multiple users from a string, such as an ID, a name, or a mention.","params":[{"name":"text","description":"Text to resolve.","type":[[["string"]]]},{"name":"users","description":"Collection of users to find in.","type":[[["Collection","<"],["Snowflake",", "],["User",">"]]]},{"name":"caseSensitive","description":"Makes finding by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes finding by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["Collection","<"],["Snowflake",", "],["User",">"]]],"meta":{"line":36,"file":"ClientUtil.js","path":"src/struct"}},{"name":"checkUser","description":"Checks if a string could be referring to a user.","params":[{"name":"text","description":"Text to check.","type":[[["string"]]]},{"name":"user","description":"User to check.","type":[[["User"]]]},{"name":"caseSensitive","description":"Makes checking by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes checking by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["boolean"]]],"meta":{"line":48,"file":"ClientUtil.js","path":"src/struct"}},{"name":"resolveMember","description":"Resolves a member from a string, such as an ID, a name, or a mention.","params":[{"name":"text","description":"Text to resolve.","type":[[["string"]]]},{"name":"members","description":"Collection of members to find in.","type":[[["Collection","<"],["Snowflake",", "],["GuildMember",">"]]]},{"name":"caseSensitive","description":"Makes finding by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes finding by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["GuildMember"]]],"meta":{"line":77,"file":"ClientUtil.js","path":"src/struct"}},{"name":"resolveMembers","description":"Resolves multiple members from a string, such as an ID, a name, or a mention.","params":[{"name":"text","description":"Text to resolve.","type":[[["string"]]]},{"name":"members","description":"Collection of members to find in.","type":[[["Collection","<"],["Snowflake",", "],["GuildMember",">"]]]},{"name":"caseSensitive","description":"Makes finding by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes finding by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["Collection","<"],["Snowflake",", "],["GuildMember",">"]]],"meta":{"line":89,"file":"ClientUtil.js","path":"src/struct"}},{"name":"checkMember","description":"Checks if a string could be referring to a member.","params":[{"name":"text","description":"Text to check.","type":[[["string"]]]},{"name":"member","description":"Member to check.","type":[[["GuildMember"]]]},{"name":"caseSensitive","description":"Makes checking by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes checking by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["boolean"]]],"meta":{"line":101,"file":"ClientUtil.js","path":"src/struct"}},{"name":"resolveChannel","description":"Resolves a channel from a string, such as an ID, a name, or a mention.","params":[{"name":"text","description":"Text to resolve.","type":[[["string"]]]},{"name":"channels","description":"Collection of channels to find in.","type":[[["Collection","<"],["Snowflake",", "],["Channel",">"]]]},{"name":"caseSensitive","description":"Makes finding by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes finding by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["Channel"]]],"meta":{"line":133,"file":"ClientUtil.js","path":"src/struct"}},{"name":"resolveChannels","description":"Resolves multiple channels from a string, such as an ID, a name, or a mention.","params":[{"name":"text","description":"Text to resolve.","type":[[["string"]]]},{"name":"channels","description":"Collection of channels to find in.","type":[[["Collection","<"],["Snowflake",", "],["Channel",">"]]]},{"name":"caseSensitive","description":"Makes finding by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes finding by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["Collection","<"],["Snowflake",", "],["Channel",">"]]],"meta":{"line":145,"file":"ClientUtil.js","path":"src/struct"}},{"name":"checkChannel","description":"Checks if a string could be referring to a channel.","params":[{"name":"text","description":"Text to check.","type":[[["string"]]]},{"name":"channel","description":"Channel to check.","type":[[["Channel"]]]},{"name":"caseSensitive","description":"Makes checking by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes checking by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["boolean"]]],"meta":{"line":157,"file":"ClientUtil.js","path":"src/struct"}},{"name":"resolveRole","description":"Resolves a role from a string, such as an ID, a name, or a mention.","params":[{"name":"text","description":"Text to resolve.","type":[[["string"]]]},{"name":"roles","description":"Collection of roles to find in.","type":[[["Collection","<"],["Snowflake",", "],["Role",">"]]]},{"name":"caseSensitive","description":"Makes finding by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes finding by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["Role"]]],"meta":{"line":185,"file":"ClientUtil.js","path":"src/struct"}},{"name":"resolveRoles","description":"Resolves multiple roles from a string, such as an ID, a name, or a mention.","params":[{"name":"text","description":"Text to resolve.","type":[[["string"]]]},{"name":"roles","description":"Collection of roles to find in.","type":[[["Collection","<"],["Snowflake",", "],["Role",">"]]]},{"name":"caseSensitive","description":"Makes finding by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes finding by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["Collection","<"],["Snowflake",", "],["Role",">"]]],"meta":{"line":197,"file":"ClientUtil.js","path":"src/struct"}},{"name":"checkRole","description":"Checks if a string could be referring to a role.","params":[{"name":"text","description":"Text to check.","type":[[["string"]]]},{"name":"role","description":"Role to check.","type":[[["Role"]]]},{"name":"caseSensitive","description":"Makes checking by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes checking by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["boolean"]]],"meta":{"line":209,"file":"ClientUtil.js","path":"src/struct"}},{"name":"resolveEmoji","description":"Resolves a custom emoji from a string, such as a name or a mention.","params":[{"name":"text","description":"Text to resolve.","type":[[["string"]]]},{"name":"emojis","description":"Collection of emojis to find in.","type":[[["Collection","<"],["Snowflake",", "],["Emoji",">"]]]},{"name":"caseSensitive","description":"Makes finding by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes finding by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["Emoji"]]],"meta":{"line":237,"file":"ClientUtil.js","path":"src/struct"}},{"name":"resolveEmojis","description":"Resolves multiple custom emojis from a string, such as a name or a mention.","params":[{"name":"text","description":"Text to resolve.","type":[[["string"]]]},{"name":"emojis","description":"Collection of emojis to find in.","type":[[["Collection","<"],["Snowflake",", "],["Emoji",">"]]]},{"name":"caseSensitive","description":"Makes finding by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes finding by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["Collection","<"],["Snowflake",", "],["Emoji",">"]]],"meta":{"line":249,"file":"ClientUtil.js","path":"src/struct"}},{"name":"checkEmoji","description":"Checks if a string could be referring to a emoji.","params":[{"name":"text","description":"Text to check.","type":[[["string"]]]},{"name":"emoji","description":"Emoji to check.","type":[[["Emoji"]]]},{"name":"caseSensitive","description":"Makes checking by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes checking by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["boolean"]]],"meta":{"line":261,"file":"ClientUtil.js","path":"src/struct"}},{"name":"resolveGuild","description":"Resolves a guild from a string, such as an ID or a name.","params":[{"name":"text","description":"Text to resolve.","type":[[["string"]]]},{"name":"guilds","description":"Collection of guilds to find in.","type":[[["Collection","<"],["Snowflake",", "],["Guild",">"]]]},{"name":"caseSensitive","description":"Makes finding by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes finding by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["Guild"]]],"meta":{"line":289,"file":"ClientUtil.js","path":"src/struct"}},{"name":"resolveGuilds","description":"Resolves multiple guilds from a string, such as an ID or a name.","params":[{"name":"text","description":"Text to resolve.","type":[[["string"]]]},{"name":"guilds","description":"Collection of guilds to find in.","type":[[["Collection","<"],["Snowflake",", "],["Guild",">"]]]},{"name":"caseSensitive","description":"Makes finding by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes finding by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["Collection","<"],["Snowflake",", "],["Guild",">"]]],"meta":{"line":301,"file":"ClientUtil.js","path":"src/struct"}},{"name":"checkGuild","description":"Checks if a string could be referring to a guild.","params":[{"name":"text","description":"Text to check.","type":[[["string"]]]},{"name":"guild","description":"Guild to check.","type":[[["Guild"]]]},{"name":"caseSensitive","description":"Makes checking by name case sensitive.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"wholeWord","description":"Makes checking by name match full word only.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["boolean"]]],"meta":{"line":313,"file":"ClientUtil.js","path":"src/struct"}},{"name":"permissionNames","description":"Array of permission names.","returns":[[["Array","<"],["string",">"]]],"meta":{"line":327,"file":"ClientUtil.js","path":"src/struct"}},{"name":"resolvePermissionNumber","description":"Resolves a permission number and returns an array of permission names.","params":[{"name":"number","description":"The permissions number.","type":[[["number"]]]}],"returns":[[["Array","<"],["string",">"]]],"meta":{"line":336,"file":"ClientUtil.js","path":"src/struct"}},{"name":"compareStreaming","description":"Compares two member objects presences and checks if they stopped or started a stream or not.\nReturns `0`, `1`, or `2` for no change, stopped, or started.","params":[{"name":"oldMember","description":"The old member.","type":[[["GuildMember"]]]},{"name":"newMember","description":"The new member.","type":[[["GuildMember"]]]}],"returns":[[["number"]]],"meta":{"line":353,"file":"ClientUtil.js","path":"src/struct"}},{"name":"fetchMember","description":"Combination of `<Client>.fetchUser()` and `<Guild>.fetchMember()`.","params":[{"name":"guild","description":"Guild to fetch in.","type":[[["Guild"]]]},{"name":"id","description":"ID of the user.","type":[[["string"]]]},{"name":"cache","description":"Whether or not to add to cache.","type":[[["boolean"]]]}],"async":true,"returns":[[["Promise","<"],["GuildMember",">"]]],"meta":{"line":369,"file":"ClientUtil.js","path":"src/struct"}},{"name":"embed","description":"Makes a MessageEmbed.","params":[{"name":"data","description":"Embed data.","optional":true,"type":[[["Object"]]]}],"returns":[[["MessageEmbed"]]],"meta":{"line":379,"file":"ClientUtil.js","path":"src/struct"}},{"name":"attachment","description":"Makes a MessageAttachment.","params":[{"name":"file","description":"The file.","type":[[["BufferResolvable"]],[["Stream"]]]},{"name":"name","description":"The filename.","optional":true,"type":[[["string"]]]}],"returns":[[["MessageAttachment"]]],"meta":{"line":389,"file":"ClientUtil.js","path":"src/struct"}},{"name":"collection","description":"Makes a Collection.","params":[{"name":"iterable","description":"Entries to fill with.","optional":true,"type":[[["Iterable"]]]}],"returns":[[["Collection"]]],"meta":{"line":398,"file":"ClientUtil.js","path":"src/struct"}}],"meta":{"line":7,"file":"ClientUtil.js","path":"src/struct"}},{"name":"Argument","description":"Represents an argument for a command.","construct":{"name":"Argument","params":[{"name":"command","description":"Command of the argument.","type":[[["Command"]]]},{"name":"options","description":"Options for the argument.","type":[[["ArgumentOptions"]]]}]},"props":[{"name":"command","description":"The command this argument belongs to.","type":[[["Command"]]],"meta":{"line":28,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"match","description":"The method to match text.","type":[[["ArgumentMatch"]]],"meta":{"line":34,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"type","description":"The type to cast to or a function to use to cast.","type":[[["ArgumentType"]],[["ArgumentTypeCaster"]]],"meta":{"line":40,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"flag","description":"The string(s) to use for flag or option match.","type":[[["string"]],[["Array","<"],["string",">"]]],"meta":{"line":46,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"multipleFlags","description":"Whether to process multiple option flags instead of just the first.","type":[[["boolean"]]],"meta":{"line":52,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"index","description":"The index to start from.","nullable":true,"type":[[["number"]]],"meta":{"line":58,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"unordered","description":"Whether or not the argument is unordered.","type":[[["boolean"]],[["number"]],[["Array","<"],["number",">"]]],"meta":{"line":64,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"limit","description":"The amount of phrases to match for rest, separate, content, or text match.","type":[[["number"]]],"meta":{"line":70,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"prompt","description":"The prompt options.","nullable":true,"type":[[["ArgumentPromptOptions"]]],"meta":{"line":76,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"default","description":"The default value of the argument or a function supplying the default value.","type":[[["DefaultValueSupplier"]],[["any"]]],"meta":{"line":82,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"otherwise","description":"The content or function supplying the content sent when argument parsing fails.","type":[[["StringResolvable"]],[["MessageOptions"]],[["MessageAdditions"]],[["OtherwiseContentSupplier"]]],"meta":{"line":88,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"modifyOtherwise","description":"Function to modify otherwise content.","nullable":true,"type":[[["OtherwiseContentModifier"]]],"meta":{"line":94,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"client","description":"The client.","type":[[["AkairoClient"]]],"meta":{"line":101,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"handler","description":"The command handler.","type":[[["CommandHandler"]]],"meta":{"line":109,"file":"Argument.js","path":"src/struct/commands/arguments"}}],"methods":[{"name":"process","description":"Processes the type casting and prompting of the argument for a phrase.","params":[{"name":"message","description":"The message that called the command.","type":[[["Message"]]]},{"name":"phrase","description":"The phrase to process.","type":[[["string"]]]}],"async":true,"returns":[[["Promise","<"],["any",">"]]],"meta":{"line":119,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"cast","description":"Casts a phrase to this argument's type.","params":[{"name":"message","description":"Message that called the command.","type":[[["Message"]]]},{"name":"phrase","description":"Phrase to process.","type":[[["string"]]]}],"returns":[[["Promise","<"],["any",">"]]],"meta":{"line":193,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"collect","description":"Collects input from the user by prompting.","params":[{"name":"message","description":"Message to prompt.","type":[[["Message"]]]},{"name":"commandInput","description":"Previous input from command if there was one.","optional":true,"type":[[["string"]]]},{"name":"parsedInput","description":"Previous parsed input from command if there was one.","optional":true,"default":null,"type":[[["any"]]]}],"async":true,"returns":[[["Promise","<("],["Flag","|"],["any",")>"]]],"meta":{"line":204,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"cast","description":"Casts a phrase to the specified type.","scope":"static","params":[{"name":"type","description":"Type to use.","type":[[["ArgumentType"]],[["ArgumentTypeCaster"]]]},{"name":"resolver","description":"Type resolver to use.","type":[[["TypeResolver"]]]},{"name":"message","description":"Message that called the command.","type":[[["Message"]]]},{"name":"phrase","description":"Phrase to process.","type":[[["string"]]]}],"async":true,"returns":[[["Promise","<"],["any",">"]]],"meta":{"line":354,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"union","description":"Creates a type from multiple types (union type).\nThe first type that resolves to a non-void value is used.","scope":"static","params":[{"name":"types","description":"Types to use.","variable":true,"type":[[["ArgumentType"]],[["ArgumentTypeCaster"]]]}],"returns":[[["ArgumentTypeCaster"]]],"meta":{"line":408,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"product","description":"Creates a type from multiple types (product type).\nOnly inputs where each type resolves with a non-void value are valid.","scope":"static","params":[{"name":"types","description":"Types to use.","variable":true,"type":[[["ArgumentType"]],[["ArgumentTypeCaster"]]]}],"returns":[[["ArgumentTypeCaster"]]],"meta":{"line":426,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"validate","description":"Creates a type with extra validation.\nIf the predicate is not true, the value is considered invalid.","scope":"static","params":[{"name":"type","description":"The type to use.","type":[[["ArgumentType"]],[["ArgumentTypeCaster"]]]},{"name":"predicate","description":"The predicate function.","type":[[["ParsedValuePredicate"]]]}],"returns":[[["ArgumentTypeCaster"]]],"meta":{"line":447,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"range","description":"Creates a type where the parsed value must be within a range.","scope":"static","params":[{"name":"type","description":"The type to use.","type":[[["ArgumentType"]],[["ArgumentTypeCaster"]]]},{"name":"min","description":"Minimum value.","type":[[["number"]]]},{"name":"max","description":"Maximum value.","type":[[["number"]]]},{"name":"inclusive","description":"Whether or not to be inclusive on the upper bound.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["ArgumentTypeCaster"]]],"meta":{"line":465,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"compose","description":"Creates a type that is the left-to-right composition of the given types.\nIf any of the types fails, the entire composition fails.","scope":"static","params":[{"name":"types","description":"Types to use.","type":[[["ArgumentType"]],[["ArgumentTypeCaster"]]]}],"returns":[[["ArgumentTypeCaster"]]],"meta":{"line":486,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"composeWithFailure","description":"Creates a type that is the left-to-right composition of the given types.\nIf any of the types fails, the composition still continues with the failure passed on.","scope":"static","params":[{"name":"types","description":"Types to use.","type":[[["ArgumentType"]],[["ArgumentTypeCaster"]]]}],"returns":[[["ArgumentTypeCaster"]]],"meta":{"line":505,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"withInput","description":"Creates a type that parses as normal but also carries the original input.\nResult is in an object `{ input, value }` and wrapped in `Flag.fail` when failed.","scope":"static","params":[{"name":"type","description":"The type to use.","type":[[["ArgumentType"]],[["ArgumentTypeCaster"]]]}],"returns":[[["ArgumentTypeCaster"]]],"meta":{"line":523,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"tagged","description":"Creates a type that parses as normal but also tags it with some data.\nResult is in an object `{ tag, value }` and wrapped in `Flag.fail` when failed.","scope":"static","params":[{"name":"type","description":"The type to use.","type":[[["ArgumentType"]],[["ArgumentTypeCaster"]]]},{"name":"tag","description":"Tag to add.\nDefaults to the `type` argument, so useful if it is a string.","optional":true,"type":[[["any"]]]}],"returns":[[["ArgumentTypeCaster"]]],"meta":{"line":543,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"taggedWithInput","description":"Creates a type that parses as normal but also tags it with some data and carries the original input.\nResult is in an object `{ tag, input, value }` and wrapped in `Flag.fail` when failed.","scope":"static","params":[{"name":"type","description":"The type to use.","type":[[["ArgumentType"]],[["ArgumentTypeCaster"]]]},{"name":"tag","description":"Tag to add.\nDefaults to the `type` argument, so useful if it is a string.","optional":true,"type":[[["any"]]]}],"returns":[[["ArgumentTypeCaster"]]],"meta":{"line":563,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"taggedUnion","description":"Creates a type from multiple types (union type).\nThe first type that resolves to a non-void value is used.\nEach type will also be tagged using `tagged` with themselves.","scope":"static","params":[{"name":"types","description":"Types to use.","variable":true,"type":[[["ArgumentType"]],[["ArgumentTypeCaster"]]]}],"returns":[[["ArgumentTypeCaster"]]],"meta":{"line":582,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"isFailure","description":"Checks if something is null, undefined, or a fail flag.","scope":"static","params":[{"name":"value","description":"Value to check.","type":[[["any"]]]}],"returns":[[["boolean"]]],"meta":{"line":600,"file":"Argument.js","path":"src/struct/commands/arguments"}}],"meta":{"line":10,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"ArgumentRunner","description":"Runs arguments.","access":"private","construct":{"name":"ArgumentRunner","params":[{"name":"command","description":"Command to run for.","type":[[["Command"]]]}]},"props":[{"name":"client","description":"The Akairo client.","type":[[["AkairoClient"]]],"meta":{"line":20,"file":"ArgumentRunner.js","path":"src/struct/commands/arguments"}},{"name":"handler","description":"The command handler.","type":[[["CommandHandler"]]],"meta":{"line":28,"file":"ArgumentRunner.js","path":"src/struct/commands/arguments"}}],"methods":[{"name":"run","description":"Runs the arguments.","params":[{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]]},{"name":"parsed","description":"Parsed data from ContentParser.","type":[[["ContentParserResult"]]]},{"name":"generator","description":"Argument generator.","type":[[["ArgumentGenerator"]]]}],"async":true,"returns":[[["Promise","<("],["Flag","|"],["any",")>"]]],"meta":{"line":39,"file":"ArgumentRunner.js","path":"src/struct/commands/arguments"}},{"name":"runOne","description":"Runs one argument.","params":[{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]]},{"name":"parsed","description":"Parsed data from ContentParser.","type":[[["ContentParserResult"]]]},{"name":"state","description":"Argument handling state.","type":[[["ArgumentRunnerState"]]]},{"name":"arg","description":"Current argument.","type":[[["Argument"]]]}],"returns":[[["Promise","<("],["Flag","|"],["any",")>"]]],"meta":{"line":82,"file":"ArgumentRunner.js","path":"src/struct/commands/arguments"}},{"name":"runPhrase","description":"Runs `phrase` match.","params":[{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]]},{"name":"parsed","description":"Parsed data from ContentParser.","type":[[["ContentParserResult"]]]},{"name":"state","description":"Argument handling state.","type":[[["ArgumentRunnerState"]]]},{"name":"arg","description":"Current argument.","type":[[["Argument"]]]}],"async":true,"returns":[[["Promise","<("],["Flag","|"],["any",")>"]]],"meta":{"line":111,"file":"ArgumentRunner.js","path":"src/struct/commands/arguments"}},{"name":"runRest","description":"Runs `rest` match.","params":[{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]]},{"name":"parsed","description":"Parsed data from ContentParser.","type":[[["ContentParserResult"]]]},{"name":"state","description":"Argument handling state.","type":[[["ArgumentRunnerState"]]]},{"name":"arg","description":"Current argument.","type":[[["Argument"]]]}],"async":true,"returns":[[["Promise","<("],["Flag","|"],["any",")>"]]],"meta":{"line":154,"file":"ArgumentRunner.js","path":"src/struct/commands/arguments"}},{"name":"runSeparate","description":"Runs `separate` match.","params":[{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]]},{"name":"parsed","description":"Parsed data from ContentParser.","type":[[["ContentParserResult"]]]},{"name":"state","description":"Argument handling state.","type":[[["ArgumentRunnerState"]]]},{"name":"arg","description":"Current argument.","type":[[["Argument"]]]}],"async":true,"returns":[[["Promise","<("],["Flag","|"],["any",")>"]]],"meta":{"line":173,"file":"ArgumentRunner.js","path":"src/struct/commands/arguments"}},{"name":"runFlag","description":"Runs `flag` match.","params":[{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]]},{"name":"parsed","description":"Parsed data from ContentParser.","type":[[["ContentParserResult"]]]},{"name":"state","description":"Argument handling state.","type":[[["ArgumentRunnerState"]]]},{"name":"arg","description":"Current argument.","type":[[["Argument"]]]}],"returns":[[["Promise","<("],["Flag","|"],["any",")>"]]],"meta":{"line":205,"file":"ArgumentRunner.js","path":"src/struct/commands/arguments"}},{"name":"runOption","description":"Runs `option` match.","params":[{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]]},{"name":"parsed","description":"Parsed data from ContentParser.","type":[[["ContentParserResult"]]]},{"name":"state","description":"Argument handling state.","type":[[["ArgumentRunnerState"]]]},{"name":"arg","description":"Current argument.","type":[[["Argument"]]]}],"async":true,"returns":[[["Promise","<("],["Flag","|"],["any",")>"]]],"meta":{"line":234,"file":"ArgumentRunner.js","path":"src/struct/commands/arguments"}},{"name":"runText","description":"Runs `text` match.","params":[{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]]},{"name":"parsed","description":"Parsed data from ContentParser.","type":[[["ContentParserResult"]]]},{"name":"state","description":"Argument handling state.","type":[[["ArgumentRunnerState"]]]},{"name":"arg","description":"Current argument.","type":[[["Argument"]]]}],"returns":[[["Promise","<("],["Flag","|"],["any",")>"]]],"meta":{"line":268,"file":"ArgumentRunner.js","path":"src/struct/commands/arguments"}},{"name":"runContent","description":"Runs `content` match.","params":[{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]]},{"name":"parsed","description":"Parsed data from ContentParser.","type":[[["ContentParserResult"]]]},{"name":"state","description":"Argument handling state.","type":[[["ArgumentRunnerState"]]]},{"name":"arg","description":"Current argument.","type":[[["Argument"]]]}],"returns":[[["Promise","<("],["Flag","|"],["any",")>"]]],"meta":{"line":282,"file":"ArgumentRunner.js","path":"src/struct/commands/arguments"}},{"name":"runRestContent","description":"Runs `restContent` match.","params":[{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]]},{"name":"parsed","description":"Parsed data from ContentParser.","type":[[["ContentParserResult"]]]},{"name":"state","description":"Argument handling state.","type":[[["ArgumentRunnerState"]]]},{"name":"arg","description":"Current argument.","type":[[["Argument"]]]}],"async":true,"returns":[[["Promise","<("],["Flag","|"],["any",")>"]]],"meta":{"line":296,"file":"ArgumentRunner.js","path":"src/struct/commands/arguments"}},{"name":"runNone","description":"Runs `none` match.","params":[{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]]},{"name":"parsed","description":"Parsed data from ContentParser.","type":[[["ContentParserResult"]]]},{"name":"state","description":"Argument handling state.","type":[[["ArgumentRunnerState"]]]},{"name":"arg","description":"Current argument.","type":[[["Argument"]]]}],"returns":[[["Promise","<("],["Flag","|"],["any",")>"]]],"meta":{"line":315,"file":"ArgumentRunner.js","path":"src/struct/commands/arguments"}},{"name":"increaseIndex","description":"Modifies state by incrementing the indices.","scope":"static","params":[{"name":"parsed","description":"Parsed data from ContentParser.","type":[[["ContentParserResult"]]]},{"name":"state","description":"Argument handling state.","type":[[["ArgumentRunnerState"]]]},{"name":"n","description":"Number of indices to increase by.","default":1,"type":[[["number"]]]}],"returns":[[["Promise","<("],["Flag","|"],["any",")>"]]],"meta":{"line":326,"file":"ArgumentRunner.js","path":"src/struct/commands/arguments"}},{"name":"isShortCircuit","description":"Checks if something is a flag that short circuits.","scope":"static","params":[{"name":"value","description":"A value.","type":[[["any"]]]}],"returns":[[["boolean"]]],"meta":{"line":341,"file":"ArgumentRunner.js","path":"src/struct/commands/arguments"}},{"name":"fromArguments","description":"Creates an argument generator from argument options.","scope":"static","params":[{"name":"args","description":"Argument options.","type":[[["Array","<"],["ArgumentOptions",">"]]]}],"returns":[[["GeneratorFunction"]]],"meta":{"line":350,"file":"ArgumentRunner.js","path":"src/struct/commands/arguments"}}],"meta":{"line":11,"file":"ArgumentRunner.js","path":"src/struct/commands/arguments"}},{"name":"TypeResolver","description":"Type resolver for command arguments.\nThe types are documented under ArgumentType.","construct":{"name":"TypeResolver","params":[{"name":"handler","description":"The command handler.","type":[[["CommandHandler"]]]}]},"props":[{"name":"client","description":"The Akairo client.","type":[[["AkairoClient"]]],"meta":{"line":16,"file":"TypeResolver.js","path":"src/struct/commands/arguments"}},{"name":"commandHandler","description":"The command handler.","type":[[["CommandHandler"]]],"meta":{"line":22,"file":"TypeResolver.js","path":"src/struct/commands/arguments"}},{"name":"inhibitorHandler","description":"The inhibitor handler.","type":[[["InhibitorHandler"]]],"meta":{"line":28,"file":"TypeResolver.js","path":"src/struct/commands/arguments"}},{"name":"listenerHandler","description":"The listener handler.","type":[[["ListenerHandler"]]],"meta":{"line":34,"file":"TypeResolver.js","path":"src/struct/commands/arguments"}},{"name":"types","description":"Collection of types.","type":[[["Collection","<"],["string",", "],["ArgumentTypeCaster",">"]]],"meta":{"line":40,"file":"TypeResolver.js","path":"src/struct/commands/arguments"}}],"methods":[{"name":"addBuiltInTypes","description":"Adds built-in types.","returns":[[["void"]]],"meta":{"line":49,"file":"TypeResolver.js","path":"src/struct/commands/arguments"}},{"name":"type","description":"Gets the resolver function for a type.","params":[{"name":"name","description":"Name of type.","type":[[["string"]]]}],"returns":[[["ArgumentTypeCaster"]]],"meta":{"line":382,"file":"TypeResolver.js","path":"src/struct/commands/arguments"}},{"name":"addType","description":"Adds a new type.","params":[{"name":"name","description":"Name of the type.","type":[[["string"]]]},{"name":"fn","description":"Function that casts the type.","type":[[["ArgumentTypeCaster"]]]}],"returns":[[["TypeResolver"]]],"meta":{"line":392,"file":"TypeResolver.js","path":"src/struct/commands/arguments"}},{"name":"addTypes","description":"Adds multiple new types.","params":[{"name":"types","description":"Object with keys as the type name and values as the cast function.","type":[[["Object"]]]}],"returns":[[["TypeResolver"]]],"meta":{"line":402,"file":"TypeResolver.js","path":"src/struct/commands/arguments"}}],"meta":{"line":10,"file":"TypeResolver.js","path":"src/struct/commands/arguments"}},{"name":"Command","description":"Represents a command.","extends":["AkairoModule"],"construct":{"name":"Command","params":[{"name":"id","description":"Command ID.","type":[[["string"]]]},{"name":"options","description":"Options for the command.","optional":true,"default":"{}","type":[[["CommandOptions"]]]}]},"props":[{"name":"aliases","description":"Command names.","type":[[["Array","<"],["string",">"]]],"meta":{"line":47,"file":"Command.js","path":"src/struct/commands"}},{"name":"channel","description":"Usable only in this channel type.","nullable":true,"type":[[["string"]]],"meta":{"line":69,"file":"Command.js","path":"src/struct/commands"}},{"name":"ownerOnly","description":"Usable only by the client owner.","type":[[["boolean"]]],"meta":{"line":75,"file":"Command.js","path":"src/struct/commands"}},{"name":"editable","description":"Whether or not this command can be ran by an edit.","type":[[["boolean"]]],"meta":{"line":81,"file":"Command.js","path":"src/struct/commands"}},{"name":"typing","description":"Whether or not to type during command execution.","type":[[["boolean"]]],"meta":{"line":87,"file":"Command.js","path":"src/struct/commands"}},{"name":"cooldown","description":"Cooldown in milliseconds.","nullable":true,"type":[[["number"]]],"meta":{"line":93,"file":"Command.js","path":"src/struct/commands"}},{"name":"ratelimit","description":"Uses allowed before cooldown.","type":[[["number"]]],"meta":{"line":99,"file":"Command.js","path":"src/struct/commands"}},{"name":"argumentDefaults","description":"Default prompt options.","type":[[["DefaultArgumentOptions"]]],"meta":{"line":105,"file":"Command.js","path":"src/struct/commands"}},{"name":"description","description":"Description of the command.","type":[[["string"]],[["any"]]],"meta":{"line":111,"file":"Command.js","path":"src/struct/commands"}},{"name":"prefix","description":"Command prefix overwrite.","type":[[["string"]],[["Array","<"],["string",">"]],[["PrefixSupplier"]]],"meta":{"line":117,"file":"Command.js","path":"src/struct/commands"}},{"name":"clientPermissions","description":"Permissions required to run command by the client.","type":[[["PermissionResolvable"]],[["Array","<"],["PermissionResolvable",">"]],[["MissingPermissionSupplier"]]],"meta":{"line":123,"file":"Command.js","path":"src/struct/commands"}},{"name":"userPermissions","description":"Permissions required to run command by the user.","type":[[["PermissionResolvable"]],[["Array","<"],["PermissionResolvable",">"]],[["MissingPermissionSupplier"]]],"meta":{"line":129,"file":"Command.js","path":"src/struct/commands"}},{"name":"regex","description":"The regex trigger for this command.","type":[[["RegExp"]],[["TriggerFunction"]]],"meta":{"line":135,"file":"Command.js","path":"src/struct/commands"}},{"name":"lock","description":"The key supplier for the locker.","nullable":true,"type":[[["KeySupplier"]]],"meta":{"line":157,"file":"Command.js","path":"src/struct/commands"}},{"name":"locker","description":"Stores the current locks.","nullable":true,"type":[[["Set","<"],["string",">"]]],"meta":{"line":172,"file":"Command.js","path":"src/struct/commands"}},{"name":"ignoreCooldown","description":"ID of user(s) to ignore cooldown or a function to ignore.","type":[[["Snowflake"]],[["Array","<"],["Snowflake",">"]],[["IgnoreCheckPredicate"]]],"meta":{"line":179,"file":"Command.js","path":"src/struct/commands"}},{"name":"ignorePermissions","description":"ID of user(s) to ignore `userPermissions` checks or a function to ignore.","type":[[["Snowflake"]],[["Array","<"],["Snowflake",">"]],[["IgnoreCheckPredicate"]]],"meta":{"line":185,"file":"Command.js","path":"src/struct/commands"}},{"name":"id","description":"ID of the module.","type":[[["string"]]],"meta":{"line":12,"file":"AkairoModule.js","path":"src/struct"}},{"name":"categoryID","description":"ID of the category this belongs to.","type":[[["string"]]],"meta":{"line":18,"file":"AkairoModule.js","path":"src/struct"}},{"name":"category","description":"Category this belongs to.","type":[[["Category"]]],"meta":{"line":24,"file":"AkairoModule.js","path":"src/struct"}},{"name":"filepath","description":"The filepath.","type":[[["string"]]],"meta":{"line":30,"file":"AkairoModule.js","path":"src/struct"}},{"name":"client","description":"The Akairo client.","type":[[["AkairoClient"]]],"meta":{"line":36,"file":"AkairoModule.js","path":"src/struct"}},{"name":"handler","description":"The handler.","type":[[["AkairoHandler"]]],"meta":{"line":42,"file":"AkairoModule.js","path":"src/struct"}}],"methods":[{"name":"condition","description":"Checks if the command should be ran by using an arbitrary condition.","params":[{"name":"message","description":"Message being handled.","type":[[["Message"]]]}],"returns":[[["boolean"]]],"meta":{"line":143,"file":"Command.js","path":"src/struct/commands"}},{"name":"before","description":"Runs before argument parsing and execution.","params":[{"name":"message","description":"Message being handled.","type":[[["Message"]]]}],"returns":[[["any"]]],"meta":{"line":151,"file":"Command.js","path":"src/struct/commands"}},{"name":"exec","description":"Executes the command.","abstract":true,"params":[{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]]},{"name":"args","description":"Evaluated arguments.","type":[[["any"]]]}],"returns":[[["any"]]],"meta":{"line":207,"file":"Command.js","path":"src/struct/commands"}},{"name":"parse","description":"Parses content using the command's arguments.","params":[{"name":"message","description":"Message to use.","type":[[["Message"]]]},{"name":"content","description":"String to parse.","type":[[["string"]]]}],"returns":[[["Promise","<("],["Flag","|"],["any",")>"]]],"meta":{"line":217,"file":"Command.js","path":"src/struct/commands"}},{"name":"reload","description":"Reloads the module.","inherits":"AkairoModule#reload","inherited":true,"returns":[[["AkairoModule"]]],"meta":{"line":49,"file":"AkairoModule.js","path":"src/struct"}},{"name":"remove","description":"Removes the module.","inherits":"AkairoModule#remove","inherited":true,"returns":[[["AkairoModule"]]],"meta":{"line":57,"file":"AkairoModule.js","path":"src/struct"}},{"name":"toString","description":"Returns the ID.","inherits":"AkairoModule#toString","inherited":true,"returns":[[["string"]]],"meta":{"line":65,"file":"AkairoModule.js","path":"src/struct"}}],"meta":{"line":13,"file":"Command.js","path":"src/struct/commands"}},{"name":"CommandHandler","description":"Loads commands and handles messages.","extends":["AkairoHandler"],"construct":{"name":"CommandHandler","params":[{"name":"client","description":"The Akairo client.","type":[[["AkairoClient"]]]},{"name":"options","description":"Options.","type":[[["CommandHandlerOptions"]]]}]},"props":[{"name":"resolver","description":"The type resolver.","type":[[["TypeResolver"]]],"meta":{"line":56,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"aliases","description":"Collecion of command aliases.","type":[[["Collection","<"],["string",", "],["string",">"]]],"meta":{"line":62,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"aliasReplacement","description":"Regular expression to automatically make command aliases for.","nullable":true,"type":[[["RegExp"]]],"meta":{"line":68,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"prefixes","description":"Collection of prefix overwrites to commands.","type":[[["Collection","<("],["string","|"],["PrefixSupplier","), "],["Set","<"],["string",">>"]]],"meta":{"line":74,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"blockClient","description":"Whether or not to block self.","type":[[["boolean"]]],"meta":{"line":80,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"blockBots","description":"Whether or not to block bots.","type":[[["boolean"]]],"meta":{"line":86,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"fetchMembers","description":"Whether or not members are fetched on each message author from a guild.","type":[[["boolean"]]],"meta":{"line":92,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"handleEdits","description":"Whether or not edits are handled.","type":[[["boolean"]]],"meta":{"line":98,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"storeMessages","description":"Whether or not to store messages in CommandUtil.","type":[[["boolean"]]],"meta":{"line":104,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"commandUtil","description":"Whether or not `message.util` is assigned.","type":[[["boolean"]]],"meta":{"line":110,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"commandUtilLifetime","description":"Milliseconds a message should exist for before its command util instance is marked for removal.","type":[[["number"]]],"meta":{"line":119,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"commandUtilSweepInterval","description":"Time interval in milliseconds for sweeping command util instances.","type":[[["number"]]],"meta":{"line":125,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"commandUtils","description":"Collection of CommandUtils.","type":[[["Collection","<"],["string",", "],["CommandUtil",">"]]],"meta":{"line":134,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"cooldowns","description":"Collection of cooldowns.","type":[[["Collection","<"],["string",", "],["CooldownData",">"]]],"meta":{"line":140,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"defaultCooldown","description":"Default cooldown for commands.","type":[[["number"]]],"meta":{"line":146,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"ignoreCooldown","description":"ID of user(s) to ignore cooldown or a function to ignore.","type":[[["Snowflake"]],[["Array","<"],["Snowflake",">"]],[["IgnoreCheckPredicate"]]],"meta":{"line":152,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"ignorePermissions","description":"ID of user(s) to ignore `userPermissions` checks or a function to ignore.","type":[[["Snowflake"]],[["Array","<"],["Snowflake",">"]],[["IgnoreCheckPredicate"]]],"meta":{"line":158,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"prompts","description":"Collection of sets of ongoing argument prompts.","type":[[["Collection","<"],["string",", "],["Set","<"],["string",">>"]]],"meta":{"line":164,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"argumentDefaults","description":"Default argument options.","type":[[["DefaultArgumentOptions"]]],"meta":{"line":170,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"prefix","description":"The prefix(es) for command parsing.","type":[[["string"]],[["Array","<"],["string",">"]],[["PrefixSupplier"]]],"meta":{"line":192,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"allowMention","description":"Whether or not mentions are allowed for prefixing.","type":[[["boolean"]],[["MentionPrefixPredicate"]]],"meta":{"line":198,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"inhibitorHandler","description":"Inhibitor handler to use.","nullable":true,"type":[[["InhibitorHandler"]]],"meta":{"line":204,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"directory","description":"Directory to commands.","type":[[["string"]]],"meta":{"line":206,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"modules","description":"Commands loaded, mapped by ID to Command.","type":[[["Collection","<"],["string",", "],["Command",">"]]],"meta":{"line":212,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"client","description":"The Akairo client.","type":[[["AkairoClient"]]],"meta":{"line":30,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"classToHandle","description":"Class to handle.","type":[[["function"]]],"meta":{"line":42,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"extensions","description":"File extensions to load.","type":[[["Set","<"],["string",">"]]],"meta":{"line":48,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"automateCategories","description":"Whether or not to automate category names.","type":[[["boolean"]]],"meta":{"line":54,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"loadFilter","description":"Function that filters files when loading.","type":[[["LoadPredicate"]]],"meta":{"line":60,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"categories","description":"Categories, mapped by ID to Category.","type":[[["Collection","<"],["string",", "],["Category",">"]]],"meta":{"line":72,"file":"AkairoHandler.js","path":"src/struct"}}],"methods":[{"name":"register","description":"Registers a module.","params":[{"name":"command","description":"Module to use.","type":[[["Command"]]]},{"name":"filepath","description":"Filepath of module.","optional":true,"type":[[["string"]]]}],"returns":[[["void"]]],"meta":{"line":245,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"deregister","description":"Deregisters a module.","params":[{"name":"command","description":"Module to use.","type":[[["Command"]]]}],"returns":[[["void"]]],"meta":{"line":299,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"handle","description":"Handles a message.","params":[{"name":"message","description":"Message to handle.","type":[[["Message"]]]}],"async":true,"returns":[[["Promise","<?"],["boolean",">"]]],"meta":{"line":338,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"handleDirectCommand","description":"Handles normal commands.","params":[{"name":"message","description":"Message to handle.","type":[[["Message"]]]},{"name":"content","description":"Content of message without command.","type":[[["string"]]]},{"name":"command","description":"Command instance.","type":[[["Command"]]]},{"name":"ignore","description":"Ignore inhibitors and other checks.","optional":true,"default":false,"type":[[["boolean"]]]}],"async":true,"returns":[[["Promise","<?"],["boolean",">"]]],"meta":{"line":400,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"handleRegexAndConditionalCommands","description":"Handles regex and conditional commands.","params":[{"name":"message","description":"Message to handle.","type":[[["Message"]]]}],"async":true,"returns":[[["Promise","<"],["boolean",">"]]],"meta":{"line":451,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"handleRegexCommands","description":"Handles regex commands.","params":[{"name":"message","description":"Message to handle.","type":[[["Message"]]]}],"async":true,"returns":[[["Promise","<"],["boolean",">"]]],"meta":{"line":462,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"handleConditionalCommands","description":"Handles conditional commands.","params":[{"name":"message","description":"Message to handle.","type":[[["Message"]]]}],"async":true,"returns":[[["Promise","<"],["boolean",">"]]],"meta":{"line":516,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"runAllTypeInhibitors","description":"Runs inhibitors with the all type.","params":[{"name":"message","description":"Message to handle.","type":[[["Message"]]]}],"async":true,"returns":[[["Promise","<"],["boolean",">"]]],"meta":{"line":549,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"runPreTypeInhibitors","description":"Runs inhibitors with the pre type.","params":[{"name":"message","description":"Message to handle.","type":[[["Message"]]]}],"async":true,"returns":[[["Promise","<"],["boolean",">"]]],"meta":{"line":574,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"runPostTypeInhibitors","description":"Runs inhibitors with the post type.","params":[{"name":"message","description":"Message to handle.","type":[[["Message"]]]},{"name":"command","description":"Command to handle.","type":[[["Command"]]]}],"async":true,"returns":[[["Promise","<"],["boolean",">"]]],"meta":{"line":594,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"runPermissionChecks","description":"Runs permission checks.","params":[{"name":"message","description":"Message that called the command.","type":[[["Message"]]]},{"name":"command","description":"Command to cooldown.","type":[[["Command"]]]}],"async":true,"returns":[[["Promise","<"],["boolean",">"]]],"meta":{"line":639,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"runCooldowns","description":"Runs cooldowns and checks if a user is under cooldown.","params":[{"name":"message","description":"Message that called the command.","type":[[["Message"]]]},{"name":"command","description":"Command to cooldown.","type":[[["Command"]]]}],"returns":[[["boolean"]]],"meta":{"line":694,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"runCommand","description":"Runs a command.","params":[{"name":"message","description":"Message to handle.","type":[[["Message"]]]},{"name":"command","description":"Command to handle.","type":[[["Command"]]]},{"name":"args","description":"Arguments to use.","type":[[["any"]]]}],"async":true,"returns":[[["Promise","<"],["void",">"]]],"meta":{"line":748,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"parseCommand","description":"Parses the command and its argument list.","params":[{"name":"message","description":"Message that called the command.","type":[[["Message"]]]}],"async":true,"returns":[[["Promise","<"],["ParsedComponentData",">"]]],"meta":{"line":769,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"parseCommandOverwrittenPrefixes","description":"Parses the command and its argument list using prefix overwrites.","params":[{"name":"message","description":"Message that called the command.","type":[[["Message"]]]}],"async":true,"returns":[[["Promise","<"],["ParsedComponentData",">"]]],"meta":{"line":786,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"parseMultiplePrefixes","description":"Runs parseWithPrefix on multiple prefixes and returns the best parse.","params":[{"name":"message","description":"Message to parse.","type":[[["Message"]]]},{"name":"pairs","description":"Pairs of prefix to associated commands.\nThat is, `[string, Set<string> | null][]`.","type":[[["Array","<"],["any",">"]]]}],"returns":[[["ParsedComponentData"]]],"meta":{"line":808,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"parseWithPrefix","description":"Tries to parse a message with the given prefix and associated commands.\nAssociated commands refer to when a prefix is used in prefix overrides.","params":[{"name":"message","description":"Message to parse.","type":[[["Message"]]]},{"name":"prefix","description":"Prefix to use.","type":[[["string"]]]},{"name":"associatedCommands","description":"Associated commands.","optional":true,"default":null,"type":[[["Set","<"],["string",">"]]]}],"returns":[[["ParsedComponentData"]]],"meta":{"line":831,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"emitError","description":"Handles errors from the handling.","params":[{"name":"err","description":"The error.","type":[[["Error"]]]},{"name":"message","description":"Message that called the command.","type":[[["Message"]]]},{"name":"command","description":"Command that errored.","optional":true,"type":[[["Command"]]]}],"returns":[[["void"]]],"meta":{"line":866,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"sweepCommandUtil","description":"Sweep command util instances from cache and returns amount sweeped.","params":[{"name":"lifetime","description":"Messages older than this will have their command util instance sweeped.\nThis is in milliseconds and defaults to the `commandUtilLifetime` option.","type":[[["number"]]]}],"returns":[[["number"]]],"meta":{"line":882,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"addPrompt","description":"Adds an ongoing prompt in order to prevent command usage in the channel.","params":[{"name":"channel","description":"Channel to add to.","type":[[["Channel"]]]},{"name":"user","description":"User to add.","type":[[["User"]]]}],"returns":[[["void"]]],"meta":{"line":902,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"removePrompt","description":"Removes an ongoing prompt.","params":[{"name":"channel","description":"Channel to remove from.","type":[[["Channel"]]]},{"name":"user","description":"User to remove.","type":[[["User"]]]}],"returns":[[["void"]]],"meta":{"line":915,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"hasPrompt","description":"Checks if there is an ongoing prompt.","params":[{"name":"channel","description":"Channel to check.","type":[[["Channel"]]]},{"name":"user","description":"User to check.","type":[[["User"]]]}],"returns":[[["boolean"]]],"meta":{"line":928,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"findCommand","description":"Finds a command by alias.","params":[{"name":"name","description":"Alias to find with.","type":[[["string"]]]}],"returns":[[["Command"]]],"meta":{"line":939,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"useInhibitorHandler","description":"Set the inhibitor handler to use.","params":[{"name":"inhibitorHandler","description":"The inhibitor handler.","type":[[["InhibitorHandler"]]]}],"returns":[[["CommandHandler"]]],"meta":{"line":948,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"useListenerHandler","description":"Set the listener handler to use.","params":[{"name":"listenerHandler","description":"The listener handler.","type":[[["ListenerHandler"]]]}],"returns":[[["CommandHandler"]]],"meta":{"line":960,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"load","description":"Loads a module, can be a module class or a filepath.","inherits":"AkairoHandler#load","inherited":true,"params":[{"name":"thing","description":"Module class or path to module.","type":[[["string"]],[["function"]]]},{"name":"isReload","description":"Whether this is a reload or not.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["AkairoModule"]]],"meta":{"line":118,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"loadAll","description":"Reads all modules from a directory and loads them.","inherits":"AkairoHandler#loadAll","inherited":true,"params":[{"name":"directory","description":"Directory to load from.\nDefaults to the directory passed in the constructor.","optional":true,"type":[[["string"]]]},{"name":"filter","description":"Filter for files, where true means it should be loaded.\nDefaults to the filter passed in the constructor.","optional":true,"type":[[["LoadPredicate"]]]}],"returns":[[["AkairoHandler"]]],"meta":{"line":152,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"remove","description":"Removes a module.","inherits":"AkairoHandler#remove","inherited":true,"params":[{"name":"id","description":"ID of the module.","type":[[["string"]]]}],"returns":[[["AkairoModule"]]],"meta":{"line":167,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"removeAll","description":"Removes all modules.","inherits":"AkairoHandler#removeAll","inherited":true,"returns":[[["AkairoHandler"]]],"meta":{"line":181,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"reload","description":"Reloads a module.","inherits":"AkairoHandler#reload","inherited":true,"params":[{"name":"id","description":"ID of the module.","type":[[["string"]]]}],"returns":[[["AkairoModule"]]],"meta":{"line":194,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"reloadAll","description":"Reloads all modules.","inherits":"AkairoHandler#reloadAll","inherited":true,"returns":[[["AkairoHandler"]]],"meta":{"line":210,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"findCategory","description":"Finds a category by name.","inherits":"AkairoHandler#findCategory","inherited":true,"params":[{"name":"name","description":"Name to find with.","type":[[["string"]]]}],"returns":[[["Category"]]],"meta":{"line":223,"file":"AkairoHandler.js","path":"src/struct"}}],"events":[{"name":"messageBlocked","description":"Emitted when a message is blocked by a pre-message inhibitor.\nThe built-in inhibitors are 'client' and 'bot'.","params":[{"name":"message","description":"Message sent.","type":[[["Message"]]]},{"name":"reason","description":"Reason for the block.","type":[[["string"]]]}],"meta":{"line":1017,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"messageInvalid","description":"Emitted when a message does not start with the prefix or match a command.","params":[{"name":"message","description":"Message sent.","type":[[["Message"]]]}],"meta":{"line":1025,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"commandDisabled","description":"Emitted when a command is found disabled.","params":[{"name":"message","description":"Message sent.","type":[[["Message"]]]},{"name":"command","description":"Command found.","type":[[["Command"]]]}],"meta":{"line":1031,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"commandBlocked","description":"Emitted when a command is blocked by a post-message inhibitor.\nThe built-in inhibitors are 'owner', 'guild', and 'dm'.","params":[{"name":"message","description":"Message sent.","type":[[["Message"]]]},{"name":"command","description":"Command blocked.","type":[[["Command"]]]},{"name":"reason","description":"Reason for the block.","type":[[["string"]]]}],"meta":{"line":1038,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"commandStarted","description":"Emitted when a command starts execution.","params":[{"name":"message","description":"Message sent.","type":[[["Message"]]]},{"name":"command","description":"Command executed.","type":[[["Command"]]]},{"name":"args","description":"The args passed to the command.","type":[[["any"]]]}],"meta":{"line":1047,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"commandFinished","description":"Emitted when a command finishes execution.","params":[{"name":"message","description":"Message sent.","type":[[["Message"]]]},{"name":"command","description":"Command executed.","type":[[["Command"]]]},{"name":"args","description":"The args passed to the command.","type":[[["any"]]]},{"name":"returnValue","description":"The command's return value.","type":[[["any"]]]}],"meta":{"line":1055,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"commandCancelled","description":"Emitted when a command is cancelled via prompt or argument cancel.","params":[{"name":"message","description":"Message sent.","type":[[["Message"]]]},{"name":"command","description":"Command executed.","type":[[["Command"]]]},{"name":"retryMessage","description":"Message to retry with.\nThis is passed when a prompt was broken out of with a message that looks like a command.","nullable":true,"type":[[["Message"]]]}],"meta":{"line":1064,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"cooldown","description":"Emitted when a command is found on cooldown.","params":[{"name":"message","description":"Message sent.","type":[[["Message"]]]},{"name":"command","description":"Command blocked.","type":[[["Command"]]]},{"name":"remaining","description":"Remaining time in milliseconds for cooldown.","type":[[["number"]]]}],"meta":{"line":1073,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"inPrompt","description":"Emitted when a user is in a command argument prompt.\nUsed to prevent usage of commands during a prompt.","params":[{"name":"message","description":"Message sent.","type":[[["Message"]]]}],"meta":{"line":1081,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"missingPermissions","description":"Emitted when a permissions check is failed.","params":[{"name":"message","description":"Message sent.","type":[[["Message"]]]},{"name":"command","description":"Command blocked.","type":[[["Command"]]]},{"name":"type","description":"Either 'client' or 'user'.","type":[[["string"]]]},{"name":"missing","description":"The missing permissions.","type":[[["any"]]]}],"meta":{"line":1088,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"error","description":"Emitted when a command or inhibitor errors.","params":[{"name":"error","description":"The error.","type":[[["Error"]]]},{"name":"message","description":"Message sent.","type":[[["Message"]]]},{"name":"command","description":"Command executed.","nullable":true,"type":[[["Command"]]]}],"meta":{"line":1097,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"load","description":"Emitted when a command is loaded.","params":[{"name":"command","description":"Module loaded.","type":[[["Command"]]]},{"name":"isReload","description":"Whether or not this was a reload.","type":[[["boolean"]]]}],"meta":{"line":1105,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"remove","description":"Emitted when a command is removed.","params":[{"name":"command","description":"Command removed.","type":[[["Command"]]]}],"meta":{"line":1112,"file":"CommandHandler.js","path":"src/struct/commands"}}],"meta":{"line":17,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"CommandUtil","description":"Command utilies.","construct":{"name":"CommandUtil","params":[{"name":"handler","description":"The command handler.","type":[[["CommandHandler"]]]},{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]]}]},"props":[{"name":"handler","description":"The command handler.","type":[[["CommandHandler"]]],"meta":{"line":14,"file":"CommandUtil.js","path":"src/struct/commands"}},{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]],"meta":{"line":20,"file":"CommandUtil.js","path":"src/struct/commands"}},{"name":"parsed","description":"The parsed components.","nullable":true,"type":[[["ParsedComponentData"]]],"meta":{"line":26,"file":"CommandUtil.js","path":"src/struct/commands"}},{"name":"shouldEdit","description":"Whether or not the last response should be edited.","type":[[["boolean"]]],"meta":{"line":32,"file":"CommandUtil.js","path":"src/struct/commands"}},{"name":"lastResponse","description":"The last response sent.","nullable":true,"type":[[["Message"]]],"meta":{"line":38,"file":"CommandUtil.js","path":"src/struct/commands"}},{"name":"messages","description":"Messages stored from prompts and prompt replies.","type":[[["Collection","<"],["Snowflake",", "],["Message",">"]]],"meta":{"line":45,"file":"CommandUtil.js","path":"src/struct/commands"}}],"methods":[{"name":"setLastResponse","description":"Sets the last repsonse.","params":[{"name":"message","description":"Message to set.","type":[[["Message"]],[["Array","<"],["Message",">"]]]}],"returns":[[["Message"]]],"meta":{"line":56,"file":"CommandUtil.js","path":"src/struct/commands"}},{"name":"addMessage","description":"Adds client prompt or user reply to messages.","params":[{"name":"message","description":"Message to add.","type":[[["Message"]],[["Array","<"],["Message",">"]]]}],"returns":[[["Message"]],[["Array","<"],["Message",">"]]],"meta":{"line":71,"file":"CommandUtil.js","path":"src/struct/commands"}},{"name":"setEditable","description":"Changes if the message should be edited.","params":[{"name":"state","description":"Change to editable or not.","type":[[["boolean"]]]}],"returns":[[["CommandUtil"]]],"meta":{"line":90,"file":"CommandUtil.js","path":"src/struct/commands"}},{"name":"send","description":"Sends a response or edits an old response if available.","params":[{"name":"content","description":"Content to send.","optional":true,"default":"''","type":[[["StringResolvable"]]]},{"name":"options","description":"Options to use.","optional":true,"default":"{}","type":[[["MessageOptions"]],[["MessageAdditions"]]]}],"async":true,"returns":[[["Promise","<("],["Message","|"],["Array","<"],["Message",">)>"]]],"meta":{"line":101,"file":"CommandUtil.js","path":"src/struct/commands"}},{"name":"sendNew","description":"Sends a response, overwriting the last response.","params":[{"name":"content","description":"Content to send.","optional":true,"default":"''","type":[[["StringResolvable"]]]},{"name":"options","description":"Options to use.","optional":true,"default":"{}","type":[[["MessageOptions"]],[["MessageAdditions"]]]}],"async":true,"returns":[[["Promise","<("],["Message","|"],["Array","<"],["Message",">)>"]]],"meta":{"line":122,"file":"CommandUtil.js","path":"src/struct/commands"}},{"name":"reply","description":"Sends a response with a mention concantenated to it.","params":[{"name":"content","description":"Content to send.","optional":true,"default":"''","type":[[["StringResolvable"]]]},{"name":"options","description":"Options to use.","optional":true,"default":"{}","type":[[["MessageOptions"]],[["MessageAdditions"]]]}],"returns":[[["Promise","<("],["Message","|"],["Array","<"],["Message",">)>"]]],"meta":{"line":135,"file":"CommandUtil.js","path":"src/struct/commands"}},{"name":"edit","description":"Edits the last response.","params":[{"name":"content","description":"Content to send.","optional":true,"default":"''","type":[[["StringResolvable"]]]},{"name":"options","description":"Options to use.","optional":true,"default":"{}","type":[[["MessageEditOptions"]],[["MessageEmbed"]]]}],"returns":[[["Promise","<"],["Message",">"]]],"meta":{"line":145,"file":"CommandUtil.js","path":"src/struct/commands"}},{"name":"transformOptions","description":"Transform options for sending.","scope":"static","params":[{"name":"content","description":"Content to send.","optional":true,"default":"''","type":[[["StringResolvable"]]]},{"name":"options","description":"Options to use.","optional":true,"default":"{}","type":[[["MessageOptions"]],[["MessageAdditions"]]]},{"name":"extra","description":"Extra options to add.","optional":true,"default":"{}","type":[[["MessageOptions"]]]}],"returns":[[["MessageOptions"]]],"meta":{"line":156,"file":"CommandUtil.js","path":"src/struct/commands"}}],"meta":{"line":8,"file":"CommandUtil.js","path":"src/struct/commands"}},{"name":"ContentParser","description":"Parses content.","access":"private","construct":{"name":"ContentParser","params":[{"name":"options","description":"Options.","type":[[["ContentParserOptions"]]]}]},"methods":[{"name":"parse","description":"Parses content.","params":[{"name":"content","description":"Content to parse.","type":[[["string"]]]}],"returns":[[["ContentParserResult"]]],"meta":{"line":450,"file":"ContentParser.js","path":"src/struct/commands"}},{"name":"getFlags","description":"Extracts the flags from argument options.","scope":"static","params":[{"name":"args","description":"Argument options.","type":[[["Array","<"],["ArgumentOptions",">"]]]}],"returns":[[["ExtractedFlags"]]],"meta":{"line":466,"file":"ContentParser.js","path":"src/struct/commands"}}],"meta":{"line":428,"file":"ContentParser.js","path":"src/struct/commands"}},{"name":"Flag","description":"Represents a special return value during commmand execution or argument parsing.","construct":{"name":"Flag","params":[{"name":"type","description":"Type of flag.","type":[[["string"]]]},{"name":"data","description":"Extra data.","optional":true,"default":"{}","type":[[["any"]]]}]},"methods":[{"name":"cancel","description":"Creates a flag that cancels the command.","scope":"static","returns":[[["Flag"]]],"meta":{"line":16,"file":"Flag.js","path":"src/struct/commands"}},{"name":"retry","description":"Creates a flag that retries with another input.","scope":"static","params":[{"name":"message","description":"Message to handle.","type":[[["Message"]]]}],"returns":[[["Flag"]]],"meta":{"line":25,"file":"Flag.js","path":"src/struct/commands"}},{"name":"fail","description":"Creates a flag that acts as argument cast failure with extra data.","scope":"static","params":[{"name":"value","description":"The extra data for the failure.","type":[[["any"]]]}],"returns":[[["Flag"]]],"meta":{"line":34,"file":"Flag.js","path":"src/struct/commands"}},{"name":"continue","description":"Creates a flag that runs another command with the rest of the arguments.","scope":"static","params":[{"name":"command","description":"Command ID.","type":[[["string"]]]},{"name":"ignore","description":"Whether or not to ignore permission checks.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"rest","description":"The rest of the arguments.\nIf this is not set, the argument handler will automatically use the rest of the content.","optional":true,"default":null,"type":[[["string"]]]}],"returns":[[["Flag"]]],"meta":{"line":46,"file":"Flag.js","path":"src/struct/commands"}},{"name":"is","description":"Checks if a value is a flag and of some type.","scope":"static","params":[{"name":"value","description":"Value to check.","type":[[["any"]]]},{"name":"type","description":"Type of flag.","type":[[["string"]]]}],"returns":[[["boolean"]]],"meta":{"line":56,"file":"Flag.js","path":"src/struct/commands"}}],"meta":{"line":6,"file":"Flag.js","path":"src/struct/commands"}},{"name":"Inhibitor","description":"Represents an inhibitor.","extends":["AkairoModule"],"construct":{"name":"Inhibitor","params":[{"name":"id","description":"Inhibitor ID.","type":[[["string"]]]},{"name":"options","description":"Options for the inhibitor.","optional":true,"default":"{}","type":[[["InhibitorOptions"]]]}]},"props":[{"name":"reason","description":"Reason emitted when command is inhibited.","type":[[["string"]]],"meta":{"line":23,"file":"Inhibitor.js","path":"src/struct/inhibitors"}},{"name":"type","description":"The type of the inhibitor for when it should run.","type":[[["string"]]],"meta":{"line":29,"file":"Inhibitor.js","path":"src/struct/inhibitors"}},{"name":"priority","description":"The priority of the inhibitor.","type":[[["number"]]],"meta":{"line":35,"file":"Inhibitor.js","path":"src/struct/inhibitors"}},{"name":"id","description":"ID of the module.","type":[[["string"]]],"meta":{"line":12,"file":"AkairoModule.js","path":"src/struct"}},{"name":"categoryID","description":"ID of the category this belongs to.","type":[[["string"]]],"meta":{"line":18,"file":"AkairoModule.js","path":"src/struct"}},{"name":"category","description":"Category this belongs to.","type":[[["Category"]]],"meta":{"line":24,"file":"AkairoModule.js","path":"src/struct"}},{"name":"filepath","description":"The filepath.","type":[[["string"]]],"meta":{"line":30,"file":"AkairoModule.js","path":"src/struct"}},{"name":"client","description":"The Akairo client.","type":[[["AkairoClient"]]],"meta":{"line":36,"file":"AkairoModule.js","path":"src/struct"}},{"name":"handler","description":"The handler.","type":[[["AkairoHandler"]]],"meta":{"line":42,"file":"AkairoModule.js","path":"src/struct"}}],"methods":[{"name":"exec","description":"Checks if message should be blocked.\nA return value of true will block the message.\nIf returning a Promise, a resolved value of true will block the message.","abstract":true,"params":[{"name":"message","description":"Message being handled.","type":[[["Message"]]]},{"name":"command","description":"Command to check.","optional":true,"type":[[["Command"]]]}],"returns":[[["boolean"]],[["Promise","<"],["boolean",">"]]],"meta":{"line":59,"file":"Inhibitor.js","path":"src/struct/inhibitors"}},{"name":"reload","description":"Reloads the module.","inherits":"AkairoModule#reload","inherited":true,"returns":[[["AkairoModule"]]],"meta":{"line":49,"file":"AkairoModule.js","path":"src/struct"}},{"name":"remove","description":"Removes the module.","inherits":"AkairoModule#remove","inherited":true,"returns":[[["AkairoModule"]]],"meta":{"line":57,"file":"AkairoModule.js","path":"src/struct"}},{"name":"toString","description":"Returns the ID.","inherits":"AkairoModule#toString","inherited":true,"returns":[[["string"]]],"meta":{"line":65,"file":"AkairoModule.js","path":"src/struct"}}],"meta":{"line":10,"file":"Inhibitor.js","path":"src/struct/inhibitors"}},{"name":"InhibitorHandler","description":"Loads inhibitors and checks messages.","extends":["AkairoHandler"],"construct":{"name":"InhibitorHandler","params":[{"name":"client","description":"The Akairo client.","type":[[["AkairoClient"]]]},{"name":"options","description":"Options.","type":[[["AkairoHandlerOptions"]]]}]},"props":[{"name":"client","description":"The Akairo client.","type":[[["AkairoClient"]]],"meta":{"line":30,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"directory","description":"The main directory to modules.","type":[[["string"]]],"meta":{"line":36,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"classToHandle","description":"Class to handle.","type":[[["function"]]],"meta":{"line":42,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"extensions","description":"File extensions to load.","type":[[["Set","<"],["string",">"]]],"meta":{"line":48,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"automateCategories","description":"Whether or not to automate category names.","type":[[["boolean"]]],"meta":{"line":54,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"loadFilter","description":"Function that filters files when loading.","type":[[["LoadPredicate"]]],"meta":{"line":60,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"modules","description":"Modules loaded, mapped by ID to AkairoModule.","type":[[["Collection","<"],["string",", "],["AkairoModule",">"]]],"meta":{"line":66,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"categories","description":"Categories, mapped by ID to Category.","type":[[["Collection","<"],["string",", "],["Category",">"]]],"meta":{"line":72,"file":"AkairoHandler.js","path":"src/struct"}}],"methods":[{"name":"test","description":"Tests inhibitors against the message.\nReturns the reason if blocked.","params":[{"name":"type","description":"Type of inhibitor, 'all', 'pre', or 'post'.","type":[[["string"]]]},{"name":"message","description":"Message to test.","type":[[["Message"]]]},{"name":"command","description":"Command to use.","optional":true,"type":[[["Command"]]]}],"async":true,"returns":[[["Promise","<("],["string","|"],["void",")>"]]],"meta":{"line":53,"file":"InhibitorHandler.js","path":"src/struct/inhibitors"}},{"name":"register","description":"Registers a module.","inherits":"AkairoHandler#register","inherited":true,"params":[{"name":"mod","description":"Module to use.","type":[[["AkairoModule"]]]},{"name":"filepath","description":"Filepath of module.","optional":true,"type":[[["string"]]]}],"returns":[[["void"]]],"meta":{"line":81,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"deregister","description":"Deregisters a module.","inherits":"AkairoHandler#deregister","inherited":true,"params":[{"name":"mod","description":"Module to use.","type":[[["AkairoModule"]]]}],"returns":[[["void"]]],"meta":{"line":106,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"load","description":"Loads a module, can be a module class or a filepath.","inherits":"AkairoHandler#load","inherited":true,"params":[{"name":"thing","description":"Module class or path to module.","type":[[["string"]],[["function"]]]},{"name":"isReload","description":"Whether this is a reload or not.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["AkairoModule"]]],"meta":{"line":118,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"loadAll","description":"Reads all modules from a directory and loads them.","inherits":"AkairoHandler#loadAll","inherited":true,"params":[{"name":"directory","description":"Directory to load from.\nDefaults to the directory passed in the constructor.","optional":true,"type":[[["string"]]]},{"name":"filter","description":"Filter for files, where true means it should be loaded.\nDefaults to the filter passed in the constructor.","optional":true,"type":[[["LoadPredicate"]]]}],"returns":[[["AkairoHandler"]]],"meta":{"line":152,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"remove","description":"Removes a module.","inherits":"AkairoHandler#remove","inherited":true,"params":[{"name":"id","description":"ID of the module.","type":[[["string"]]]}],"returns":[[["AkairoModule"]]],"meta":{"line":167,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"removeAll","description":"Removes all modules.","inherits":"AkairoHandler#removeAll","inherited":true,"returns":[[["AkairoHandler"]]],"meta":{"line":181,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"reload","description":"Reloads a module.","inherits":"AkairoHandler#reload","inherited":true,"params":[{"name":"id","description":"ID of the module.","type":[[["string"]]]}],"returns":[[["AkairoModule"]]],"meta":{"line":194,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"reloadAll","description":"Reloads all modules.","inherits":"AkairoHandler#reloadAll","inherited":true,"returns":[[["AkairoHandler"]]],"meta":{"line":210,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"findCategory","description":"Finds a category by name.","inherits":"AkairoHandler#findCategory","inherited":true,"params":[{"name":"name","description":"Name to find with.","type":[[["string"]]]}],"returns":[[["Category"]]],"meta":{"line":223,"file":"AkairoHandler.js","path":"src/struct"}}],"events":[{"name":"load","description":"Emitted when an inhibitor is loaded.","params":[{"name":"inhibitor","description":"Inhibitor loaded.","type":[[["Inhibitor"]]]},{"name":"isReload","description":"Whether or not this was a reload.","type":[[["boolean"]]]}],"meta":{"line":145,"file":"InhibitorHandler.js","path":"src/struct/inhibitors"}},{"name":"remove","description":"Emitted when an inhibitor is removed.","params":[{"name":"inhibitor","description":"Inhibitor removed.","type":[[["Inhibitor"]]]}],"meta":{"line":152,"file":"InhibitorHandler.js","path":"src/struct/inhibitors"}}],"meta":{"line":12,"file":"InhibitorHandler.js","path":"src/struct/inhibitors"}},{"name":"Listener","description":"Represents a listener.","extends":["AkairoModule"],"construct":{"name":"Listener","params":[{"name":"id","description":"Listener ID.","type":[[["string"]]]},{"name":"options","description":"Options for the listener.","optional":true,"default":"{}","type":[[["ListenerOptions"]]]}]},"props":[{"name":"emitter","description":"The event emitter.","type":[[["string"]],[["EventEmitter"]]],"meta":{"line":23,"file":"Listener.js","path":"src/struct/listeners"}},{"name":"event","description":"The event name listened to.","type":[[["string"]]],"meta":{"line":29,"file":"Listener.js","path":"src/struct/listeners"}},{"name":"type","description":"Type of listener.","type":[[["string"]]],"meta":{"line":35,"file":"Listener.js","path":"src/struct/listeners"}},{"name":"id","description":"ID of the module.","type":[[["string"]]],"meta":{"line":12,"file":"AkairoModule.js","path":"src/struct"}},{"name":"categoryID","description":"ID of the category this belongs to.","type":[[["string"]]],"meta":{"line":18,"file":"AkairoModule.js","path":"src/struct"}},{"name":"category","description":"Category this belongs to.","type":[[["Category"]]],"meta":{"line":24,"file":"AkairoModule.js","path":"src/struct"}},{"name":"filepath","description":"The filepath.","type":[[["string"]]],"meta":{"line":30,"file":"AkairoModule.js","path":"src/struct"}},{"name":"client","description":"The Akairo client.","type":[[["AkairoClient"]]],"meta":{"line":36,"file":"AkairoModule.js","path":"src/struct"}},{"name":"handler","description":"The handler.","type":[[["AkairoHandler"]]],"meta":{"line":42,"file":"AkairoModule.js","path":"src/struct"}}],"methods":[{"name":"exec","description":"Executes the listener.","abstract":true,"params":[{"name":"args","description":"Arguments.","optional":true,"variable":true,"type":[[["args"]]]}],"returns":[[["any"]]],"meta":{"line":56,"file":"Listener.js","path":"src/struct/listeners"}},{"name":"reload","description":"Reloads the module.","inherits":"AkairoModule#reload","inherited":true,"returns":[[["AkairoModule"]]],"meta":{"line":49,"file":"AkairoModule.js","path":"src/struct"}},{"name":"remove","description":"Removes the module.","inherits":"AkairoModule#remove","inherited":true,"returns":[[["AkairoModule"]]],"meta":{"line":57,"file":"AkairoModule.js","path":"src/struct"}},{"name":"toString","description":"Returns the ID.","inherits":"AkairoModule#toString","inherited":true,"returns":[[["string"]]],"meta":{"line":65,"file":"AkairoModule.js","path":"src/struct"}}],"meta":{"line":10,"file":"Listener.js","path":"src/struct/listeners"}},{"name":"ListenerHandler","description":"Loads listeners and registers them with EventEmitters.","extends":["AkairoHandler"],"construct":{"name":"ListenerHandler","params":[{"name":"client","description":"The Akairo client.","type":[[["AkairoClient"]]]},{"name":"options","description":"Options.","type":[[["AkairoHandlerOptions"]]]}]},"props":[{"name":"emitters","description":"EventEmitters for use, mapped by name to EventEmitter.\nBy default, 'client' is set to the given client.","type":[[["Collection","<"],["string",", "],["EventEmitter",">"]]],"meta":{"line":38,"file":"ListenerHandler.js","path":"src/struct/listeners"}},{"name":"client","description":"The Akairo client.","type":[[["AkairoClient"]]],"meta":{"line":30,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"directory","description":"The main directory to modules.","type":[[["string"]]],"meta":{"line":36,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"classToHandle","description":"Class to handle.","type":[[["function"]]],"meta":{"line":42,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"extensions","description":"File extensions to load.","type":[[["Set","<"],["string",">"]]],"meta":{"line":48,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"automateCategories","description":"Whether or not to automate category names.","type":[[["boolean"]]],"meta":{"line":54,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"loadFilter","description":"Function that filters files when loading.","type":[[["LoadPredicate"]]],"meta":{"line":60,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"modules","description":"Modules loaded, mapped by ID to AkairoModule.","type":[[["Collection","<"],["string",", "],["AkairoModule",">"]]],"meta":{"line":66,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"categories","description":"Categories, mapped by ID to Category.","type":[[["Collection","<"],["string",", "],["Category",">"]]],"meta":{"line":72,"file":"AkairoHandler.js","path":"src/struct"}}],"methods":[{"name":"register","description":"Registers a module.","params":[{"name":"listener","description":"Module to use.","type":[[["Listener"]]]},{"name":"filepath","description":"Filepath of module.","optional":true,"type":[[["string"]]]}],"returns":[[["void"]]],"meta":{"line":60,"file":"ListenerHandler.js","path":"src/struct/listeners"}},{"name":"deregister","description":"Deregisters a module.","params":[{"name":"listener","description":"Module to use.","type":[[["Listener"]]]}],"returns":[[["void"]]],"meta":{"line":72,"file":"ListenerHandler.js","path":"src/struct/listeners"}},{"name":"addToEmitter","description":"Adds a listener to the EventEmitter.","params":[{"name":"id","description":"ID of the listener.","type":[[["string"]]]}],"returns":[[["Listener"]]],"meta":{"line":82,"file":"ListenerHandler.js","path":"src/struct/listeners"}},{"name":"removeFromEmitter","description":"Removes a listener from the EventEmitter.","params":[{"name":"id","description":"ID of the listener.","type":[[["string"]]]}],"returns":[[["Listener"]]],"meta":{"line":103,"file":"ListenerHandler.js","path":"src/struct/listeners"}},{"name":"setEmitters","description":"Sets custom emitters.","params":[{"name":"emitters","description":"Emitters to use.\nThe key is the name and value is the emitter.","type":[[["Object"]]]}],"returns":[[["ListenerHandler"]]],"meta":{"line":120,"file":"ListenerHandler.js","path":"src/struct/listeners"}},{"name":"load","description":"Loads a module, can be a module class or a filepath.","inherits":"AkairoHandler#load","inherited":true,"params":[{"name":"thing","description":"Module class or path to module.","type":[[["string"]],[["function"]]]},{"name":"isReload","description":"Whether this is a reload or not.","optional":true,"default":false,"type":[[["boolean"]]]}],"returns":[[["AkairoModule"]]],"meta":{"line":118,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"loadAll","description":"Reads all modules from a directory and loads them.","inherits":"AkairoHandler#loadAll","inherited":true,"params":[{"name":"directory","description":"Directory to load from.\nDefaults to the directory passed in the constructor.","optional":true,"type":[[["string"]]]},{"name":"filter","description":"Filter for files, where true means it should be loaded.\nDefaults to the filter passed in the constructor.","optional":true,"type":[[["LoadPredicate"]]]}],"returns":[[["AkairoHandler"]]],"meta":{"line":152,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"remove","description":"Removes a module.","inherits":"AkairoHandler#remove","inherited":true,"params":[{"name":"id","description":"ID of the module.","type":[[["string"]]]}],"returns":[[["AkairoModule"]]],"meta":{"line":167,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"removeAll","description":"Removes all modules.","inherits":"AkairoHandler#removeAll","inherited":true,"returns":[[["AkairoHandler"]]],"meta":{"line":181,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"reload","description":"Reloads a module.","inherits":"AkairoHandler#reload","inherited":true,"params":[{"name":"id","description":"ID of the module.","type":[[["string"]]]}],"returns":[[["AkairoModule"]]],"meta":{"line":194,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"reloadAll","description":"Reloads all modules.","inherits":"AkairoHandler#reloadAll","inherited":true,"returns":[[["AkairoHandler"]]],"meta":{"line":210,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"findCategory","description":"Finds a category by name.","inherits":"AkairoHandler#findCategory","inherited":true,"params":[{"name":"name","description":"Name to find with.","type":[[["string"]]]}],"returns":[[["Category"]]],"meta":{"line":223,"file":"AkairoHandler.js","path":"src/struct"}}],"events":[{"name":"load","description":"Emitted when a listener is loaded.","params":[{"name":"listener","description":"Listener loaded.","type":[[["Listener"]]]},{"name":"isReload","description":"Whether or not this was a reload.","type":[[["boolean"]]]}],"meta":{"line":180,"file":"ListenerHandler.js","path":"src/struct/listeners"}},{"name":"remove","description":"Emitted when a listener is removed.","params":[{"name":"listener","description":"Listener removed.","type":[[["Listener"]]]}],"meta":{"line":187,"file":"ListenerHandler.js","path":"src/struct/listeners"}}],"meta":{"line":13,"file":"ListenerHandler.js","path":"src/struct/listeners"}},{"name":"AkairoError","description":"Represents an error for Akairo.","extends":["Error"],"construct":{"name":"AkairoError","params":[{"name":"key","description":"Error key.","type":[[["string"]]]},{"name":"args","description":"Arguments.","variable":true,"type":[[["any"]]]}]},"meta":{"line":28,"file":"AkairoError.js","path":"src/util"}},{"name":"Category","description":"A group of modules.","extends":["Collection"],"construct":{"name":"Category","params":[{"name":"id","description":"ID of the category.","type":[[["string"]]]},{"name":"iterable","description":"Entries to set.","optional":true,"type":[[["Iterable"]]]}]},"props":[{"name":"id","description":"ID of the category.","type":[[["string"]]],"meta":{"line":17,"file":"Category.js","path":"src/util"}}],"methods":[{"name":"reloadAll","description":"Calls `reload()` on all items in this category.","returns":[[["Category"]]],"meta":{"line":24,"file":"Category.js","path":"src/util"}},{"name":"removeAll","description":"Calls `remove()` on all items in this category.","returns":[[["Category"]]],"meta":{"line":36,"file":"Category.js","path":"src/util"}},{"name":"toString","description":"Returns the ID.","returns":[[["string"]]],"meta":{"line":48,"file":"Category.js","path":"src/util"}}],"meta":{"line":9,"file":"Category.js","path":"src/util"}}],"interfaces":[],"typedefs":[{"name":"ProviderOptions","description":"Options to use for providers.","type":[[["Object"]]],"props":[{"name":"idColumn","description":"Column for the unique key, defaults to 'id'.","optional":true,"default":"'id'","type":[[["string"]]]},{"name":"dataColumn","description":"Column for JSON data.\nIf not provided, the provider will use all columns of the table.\nIf provided, only one column will be used, but it will be more flexible due to being parsed as JSON.\nFor Sequelize, note that the model has to specify the type of the column as JSON or JSONB.","optional":true,"type":[[["string"]]]}],"meta":{"line":74,"file":"Provider.js","path":"src/providers"}},{"name":"AkairoOptions","description":"Options for the client.","type":[[["Object"]]],"props":[{"name":"ownerID","description":"Discord ID of the client owner(s).","optional":true,"default":"''","type":[[["Snowflake"]],[["Array","<"],["Snowflake",">"]]]}],"meta":{"line":45,"file":"AkairoClient.js","path":"src/struct"}},{"name":"AkairoHandlerOptions","description":"Options for module loading and handling.","type":[[["Object"]]],"props":[{"name":"directory","description":"Directory to modules.","optional":true,"type":[[["string"]]]},{"name":"classToHandle","description":"Only classes that extends this class can be handled.","optional":true,"default":"AkairoModule","type":[[["function"]]]},{"name":"extensions","description":"File extensions to load.\nBy default this is .js, .json, and .ts files.","optional":true,"type":[[["Array","<"],["string",">"]],[["Set","<"],["string",">"]]]},{"name":"automateCategories","description":"Whether or not to set each module's category to its parent directory name.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"loadFilter","description":"Filter for files to be loaded.\nCan be set individually for each handler by overriding the `loadAll` method.","optional":true,"type":[[["LoadPredicate"]]]}],"meta":{"line":270,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"LoadPredicate","description":"Function for filtering files when loading.\nTrue means the file should be loaded.","type":[[["function"]]],"params":[{"name":"filepath","description":"Filepath of file.","type":[[["String"]]]}],"returns":[[["boolean"]]],"meta":{"line":282,"file":"AkairoHandler.js","path":"src/struct"}},{"name":"AkairoModuleOptions","description":"Options for module.","type":[[["Object"]]],"props":[{"name":"category","description":"Category ID for organization purposes.","optional":true,"default":"'default'","type":[[["string"]]]}],"meta":{"line":72,"file":"AkairoModule.js","path":"src/struct"}},{"name":"ArgumentOptions","description":"Options for how an argument parses text.","type":[[["Object"]]],"props":[{"name":"id","description":"ID of the argument for use in the args object.\nThis does nothing inside an ArgumentGenerator.","type":[[["string"]]]},{"name":"match","description":"Method to match text.","optional":true,"default":"'phrase'","type":[[["ArgumentMatch"]]]},{"name":"type","description":"Type to cast to.","optional":true,"default":"'string'","type":[[["ArgumentType"]],[["ArgumentTypeCaster"]]]},{"name":"flag","description":"The string(s) to use as the flag for flag or option match.","optional":true,"type":[[["string"]],[["Array","<"],["string",">"]]]},{"name":"multipleFlags","description":"Whether or not to have flags process multiple inputs.\nFor option flags, this works like the separate match; the limit option will also work here.\nFor flags, this will count the number of occurrences.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"index","description":"Index of phrase to start from.\nApplicable to phrase, text, content, rest, or separate match only.\nIgnored when used with the unordered option.","optional":true,"type":[[["number"]]]},{"name":"unordered","description":"Marks the argument as unordered.\nEach phrase is evaluated in order until one matches (no input at all means no evaluation).\nPassing in a number forces evaluation from that index onwards.\nPassing in an array of numbers forces evaluation on those indices only.\nIf there is a match, that index is considered used and future unordered args will not check that index again.\nIf there is no match, then the prompting or default value is used.\nApplicable to phrase match only.","optional":true,"default":false,"type":[[["boolean"]],[["number"]],[["Array","<"],["number",">"]]]},{"name":"limit","description":"Amount of phrases to match when matching more than one.\nApplicable to text, content, rest, or separate match only.","optional":true,"default":"Infinity","type":[[["number"]]]},{"name":"default","description":"Default value if no input or did not cast correctly.\nIf using a flag match, setting the default value to a non-void value inverses the result.","optional":true,"default":null,"type":[[["DefaultValueSupplier"]],[["any"]]]},{"name":"otherwise","description":"Text sent if argument parsing fails.\nThis overrides the `default` option and all prompt options.","optional":true,"type":[[["StringResolvable"]],[["MessageOptions"]],[["MessageAdditions"]],[["OtherwiseContentSupplier"]]]},{"name":"modifyOtherwise","description":"Function to modify otherwise content.","optional":true,"type":[[["OtherwiseContentModifier"]]]},{"name":"prompt","description":"Prompt options for when user does not provide input.","optional":true,"type":[[["ArgumentPromptOptions"]]]}],"meta":{"line":607,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"ArgumentPromptData","description":"Data passed to argument prompt functions.","type":[[["Object"]]],"props":[{"name":"retries","description":"Amount of retries so far.","type":[[["number"]]]},{"name":"infinite","description":"Whether the prompt is infinite or not.","type":[[["boolean"]]]},{"name":"message","description":"The message that caused the prompt.","type":[[["Message"]]]},{"name":"phrase","description":"The input phrase that caused the prompt if there was one, otherwise an empty string.","type":[[["string"]]]}],"params":[{"name":"failure","description":"The value that failed if there was one, otherwise null.","type":[[["void"]],[["Flag"]]]}],"meta":{"line":638,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"ArgumentPromptOptions","description":"A prompt to run if the user did not input the argument correctly.\nCan only be used if there is not a default value (unless optional is true).","type":[[["Object"]]],"props":[{"name":"retries","description":"Amount of retries allowed.","optional":true,"default":1,"type":[[["number"]]]},{"name":"time","description":"Time to wait for input.","optional":true,"default":30000,"type":[[["number"]]]},{"name":"cancelWord","description":"Word to use for cancelling the command.","optional":true,"default":"'cancel'","type":[[["string"]]]},{"name":"stopWord","description":"Word to use for ending infinite prompts.","optional":true,"default":"'stop'","type":[[["string"]]]},{"name":"optional","description":"Prompts only when argument is provided but was not of the right type.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"infinite","description":"Prompts forever until the stop word, cancel word, time limit, or retry limit.\nNote that the retry count resets back to one on each valid entry.\nThe final evaluated argument will be an array of the inputs.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"limit","description":"Amount of inputs allowed for an infinite prompt before finishing.","optional":true,"default":"Infinity","type":[[["number"]]]},{"name":"breakout","description":"Whenever an input matches the format of a command, this option controls whether or not to cancel this command and run that command.\nThe command to be run may be the same command or some other command.","optional":true,"default":true,"type":[[["boolean"]]]},{"name":"start","description":"Text sent on start of prompt.","optional":true,"type":[[["StringResolvable"]],[["MessageOptions"]],[["MessageAdditions"]],[["PromptContentSupplier"]]]},{"name":"retry","description":"Text sent on a retry (failure to cast type).","optional":true,"type":[[["StringResolvable"]],[["MessageOptions"]],[["MessageAdditions"]],[["PromptContentSupplier"]]]},{"name":"timeout","description":"Text sent on collector time out.","optional":true,"type":[[["StringResolvable"]],[["MessageOptions"]],[["MessageAdditions"]],[["PromptContentSupplier"]]]},{"name":"ended","description":"Text sent on amount of tries reaching the max.","optional":true,"type":[[["StringResolvable"]],[["MessageOptions"]],[["MessageAdditions"]],[["PromptContentSupplier"]]]},{"name":"cancel","description":"Text sent on cancellation of command.","optional":true,"type":[[["StringResolvable"]],[["MessageOptions"]],[["MessageAdditions"]],[["PromptContentSupplier"]]]},{"name":"modifyStart","description":"Function to modify start prompts.","optional":true,"type":[[["PromptContentModifier"]]]},{"name":"modifyRetry","description":"Function to modify retry prompts.","optional":true,"type":[[["PromptContentModifier"]]]},{"name":"modifyTimeout","description":"Function to modify timeout messages.","optional":true,"type":[[["PromptContentModifier"]]]},{"name":"modifyEnded","description":"Function to modify out of tries messages.","optional":true,"type":[[["PromptContentModifier"]]]},{"name":"modifyCancel","description":"Function to modify cancel messages.","optional":true,"type":[[["PromptContentModifier"]]]}],"meta":{"line":648,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"ArgumentMatch","description":"The method to match arguments from text.\n- `phrase` matches by the order of the phrases inputted.\nIt ignores phrases that matches a flag.\n- `flag` matches phrases that are the same as its flag.\nThe evaluated argument is either true or false.\n- `option` matches phrases that starts with the flag.\nThe phrase after the flag is the evaluated argument.\n- `rest` matches the rest of the phrases.\nIt ignores phrases that matches a flag.\nIt preserves the original whitespace between phrases and the quotes around phrases.\n- `separate` matches the rest of the phrases and processes each individually.\nIt ignores phrases that matches a flag.\n- `text` matches the entire text, except for the command.\nIt ignores phrases that matches a flag.\nIt preserves the original whitespace between phrases and the quotes around phrases.\n- `content` matches the entire text as it was inputted, except for the command.\nIt preserves the original whitespace between phrases and the quotes around phrases.\n- `restContent` matches the rest of the text as it was inputted.\nIt preserves the original whitespace between phrases and the quotes around phrases.\n- `none` matches nothing at all and an empty string will be used for type operations.","type":[[["string"]]],"meta":{"line":675,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"ArgumentType","description":"The type that the argument should be cast to.\n- `string` does not cast to any type.\n- `lowercase` makes the input lowercase.\n- `uppercase` makes the input uppercase.\n- `charCodes` transforms the input to an array of char codes.\n- `number` casts to a number.\n- `integer` casts to an integer.\n- `bigint` casts to a big integer.\n- `url` casts to an `URL` object.\n- `date` casts to a `Date` object.\n- `color` casts a hex code to an integer.\n- `commandAlias` tries to resolve to a command from an alias.\n- `command` matches the ID of a command.\n- `inhibitor` matches the ID of an inhibitor.\n- `listener` matches the ID of a listener.\n\nPossible Discord-related types.\nThese types can be plural (add an 's' to the end) and a collection of matching objects will be used.\n- `user` tries to resolve to a user.\n- `member` tries to resolve to a member.\n- `relevant` tries to resolve to a relevant user, works in both guilds and DMs.\n- `channel` tries to resolve to a channel.\n- `textChannel` tries to resolve to a text channel.\n- `voiceChannel` tries to resolve to a voice channel.\n- `role` tries to resolve to a role.\n- `emoji` tries to resolve to a custom emoji.\n- `guild` tries to resolve to a guild.\n\nOther Discord-related types:\n- `message` tries to fetch a message from an ID within the channel.\n- `guildMessage` tries to fetch a message from an ID within the guild.\n- `relevantMessage` is a combination of the above, works in both guilds and DMs.\n- `invite` tries to fetch an invite object from a link.\n- `userMention` matches a mention of a user.\n- `memberMention` matches a mention of a guild member.\n- `channelMention` matches a mention of a channel.\n- `roleMention` matches a mention of a role.\n- `emojiMention` matches a mention of an emoji.\n\nAn array of strings can be used to restrict input to only those strings, case insensitive.\nThe array can also contain an inner array of strings, for aliases.\nIf so, the first entry of the array will be used as the final argument.\n\nA regular expression can also be used.\nThe evaluated argument will be an object containing the `match` and `matches` if global.","type":[[["string"]],[["Array","<"],["string",">"]]],"meta":{"line":699,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"ArgumentTypeCaster","description":"A function for processing user input to use as an argument.\nA void return value will use the default value for the argument or start a prompt.\nAny other truthy return value will be used as the evaluated argument.\nIf returning a Promise, the resolved value will go through the above steps.","type":[[["function"]]],"params":[{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]]},{"name":"phrase","description":"The user input.","type":[[["string"]]]}],"returns":[[["any"]]],"meta":{"line":748,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"FailureData","description":"Data passed to functions that run when things failed.","type":[[["Object"]]],"props":[{"name":"phrase","description":"The input phrase that failed if there was one, otherwise an empty string.","type":[[["string"]]]}],"params":[{"name":"failure","description":"The value that failed if there was one, otherwise null.","type":[[["void"]],[["Flag"]]]}],"meta":{"line":768,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"DefaultArgumentOptions","description":"Defaults for argument options.","type":[[["Object"]]],"props":[{"name":"prompt","description":"Default prompt options.","optional":true,"type":[[["ArgumentPromptOptions"]]]},{"name":"otherwise","description":"Default text sent if argument parsing fails.","optional":true,"type":[[["StringResolvable"]],[["MessageOptions"]],[["MessageAdditions"]],[["OtherwiseContentSupplier"]]]},{"name":"modifyOtherwise","description":"Function to modify otherwise content.","optional":true,"type":[[["OtherwiseContentModifier"]]]}],"meta":{"line":775,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"DefaultValueSupplier","description":"Function get the default value of the argument.","type":[[["function"]]],"params":[{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]]},{"name":"data","description":"Miscellaneous data.","type":[[["FailureData"]]]}],"returns":[[["any"]]],"meta":{"line":783,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"ParsedValuePredicate","description":"A function for validating parsed arguments.","type":[[["function"]]],"params":[{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]]},{"name":"phrase","description":"The user input.","type":[[["string"]]]},{"name":"value","description":"The parsed value.","type":[[["any"]]]}],"returns":[[["boolean"]]],"meta":{"line":791,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"OtherwiseContentModifier","description":"A function modifying a prompt text.","type":[[["function"]]],"params":[{"name":"text","description":"Text to modify.","type":[[["string"]],[["MessageEmbed"]],[["MessageAttachment"]],[["Array","<"],["MessageAttachment",">"]],[["MessageOptions"]]]},{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]]},{"name":"data","description":"Miscellaneous data.","type":[[["FailureData"]]]}],"returns":[[["StringResolvable"]],[["MessageOptions"]],[["MessageAdditions"]],[["Promise","<("],["StringResolvable","|"],["MessageOptions","|"],["MessageAdditions",")>"]]],"meta":{"line":800,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"OtherwiseContentSupplier","description":"A function returning the content if argument parsing fails.","type":[[["function"]]],"params":[{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]]},{"name":"data","description":"Miscellaneous data.","type":[[["FailureData"]]]}],"returns":[[["StringResolvable"]],[["MessageOptions"]],[["MessageAdditions"]],[["Promise","<("],["StringResolvable","|"],["MessageOptions","|"],["MessageAdditions",")>"]]],"meta":{"line":809,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"PromptContentModifier","description":"A function modifying a prompt text.","type":[[["function"]]],"params":[{"name":"text","description":"Text from the prompt to modify.","type":[[["string"]],[["MessageEmbed"]],[["MessageAttachment"]],[["Array","<"],["MessageAttachment",">"]],[["MessageOptions"]]]},{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]]},{"name":"data","description":"Miscellaneous data.","type":[[["ArgumentPromptData"]]]}],"returns":[[["StringResolvable"]],[["MessageOptions"]],[["MessageAdditions"]],[["Promise","<("],["StringResolvable","|"],["MessageOptions","|"],["MessageAdditions",")>"]]],"meta":{"line":817,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"PromptContentSupplier","description":"A function returning text for the prompt.","type":[[["function"]]],"params":[{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]]},{"name":"data","description":"Miscellaneous data.","type":[[["ArgumentPromptData"]]]}],"returns":[[["StringResolvable"]],[["MessageOptions"]],[["MessageAdditions"]],[["Promise","<("],["StringResolvable","|"],["MessageOptions","|"],["MessageAdditions",")>"]]],"meta":{"line":826,"file":"Argument.js","path":"src/struct/commands/arguments"}},{"name":"ArgumentRunnerState","description":"State for the argument runner.","type":[[["Object"]]],"props":[{"name":"usedIndices","description":"Indices already used for unordered match.","type":[[["Set","<"],["number",">"]]]},{"name":"phraseIndex","description":"Index in terms of phrases.","type":[[["number"]]]},{"name":"index","description":"Index in terms of the raw strings.","type":[[["number"]]]}],"meta":{"line":364,"file":"ArgumentRunner.js","path":"src/struct/commands/arguments"}},{"name":"CommandOptions","description":"Options to use for command execution behavior.\nAlso includes properties from AkairoModuleOptions.","type":[[["AkairoModuleOptions"]]],"props":[{"name":"aliases","description":"Command names.","optional":true,"default":"[]","type":[[["Array","<"],["string",">"]]]},{"name":"args","description":"Argument options or generator.","optional":true,"default":"[]","type":[[["Array","<"],["ArgumentOptions",">"]],[["ArgumentGenerator"]]]},{"name":"quoted","description":"Whether or not to consider quotes.","optional":true,"default":true,"type":[[["boolean"]]]},{"name":"separator","description":"Custom separator for argument input.","optional":true,"type":[[["string"]]]},{"name":"flags","description":"Flags to use when using an ArgumentGenerator.","optional":true,"default":"[]","type":[[["Array","<"],["string",">"]]]},{"name":"optionFlags","description":"Option flags to use when using an ArgumentGenerator.","optional":true,"default":"[]","type":[[["Array","<"],["string",">"]]]},{"name":"channel","description":"Restricts channel to either 'guild' or 'dm'.","optional":true,"type":[[["string"]]]},{"name":"ownerOnly","description":"Whether or not to allow client owner(s) only.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"typing","description":"Whether or not to type in channel during execution.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"editable","description":"Whether or not message edits will run this command.","optional":true,"default":true,"type":[[["boolean"]]]},{"name":"cooldown","description":"The command cooldown in milliseconds.","optional":true,"type":[[["number"]]]},{"name":"ratelimit","description":"Amount of command uses allowed until cooldown.","optional":true,"default":1,"type":[[["number"]]]},{"name":"prefix","description":"The prefix(es) to overwrite the global one for this command.","optional":true,"type":[[["string"]],[["Array","<"],["string",">"]],[["PrefixSupplier"]]]},{"name":"userPermissions","description":"Permissions required by the user to run this command.","optional":true,"type":[[["PermissionResolvable"]],[["Array","<"],["PermissionResolvable",">"]],[["MissingPermissionSupplier"]]]},{"name":"clientPermissions","description":"Permissions required by the client to run this command.","optional":true,"type":[[["PermissionResolvable"]],[["Array","<"],["PermissionResolvable",">"]],[["MissingPermissionSupplier"]]]},{"name":"regex","description":"A regex to match in messages that are not directly commands.\nThe args object will have `match` and `matches` properties.","optional":true,"type":[[["RegExp"]],[["RegexSupplier"]]]},{"name":"condition","description":"Whether or not to run on messages that are not directly commands.","optional":true,"type":[[["ExecutionPredicate"]]]},{"name":"before","description":"Function to run before argument parsing and execution.","optional":true,"type":[[["BeforeAction"]]]},{"name":"lock","description":"The key type or key generator for the locker. If lock is a string, it's expected one of 'guild', 'channel', or 'user'.","optional":true,"type":[[["KeySupplier"]],[["string"]]]},{"name":"ignoreCooldown","description":"ID of user(s) to ignore cooldown or a function to ignore.","optional":true,"type":[[["Snowflake"]],[["Array","<"],["Snowflake",">"]],[["IgnoreCheckPredicate"]]]},{"name":"ignorePermissions","description":"ID of user(s) to ignore `userPermissions` checks or a function to ignore.","optional":true,"type":[[["Snowflake"]],[["Array","<"],["Snowflake",">"]],[["IgnoreCheckPredicate"]]]},{"name":"argumentDefaults","description":"The default argument options.","optional":true,"type":[[["DefaultArgumentOptions"]]]},{"name":"description","description":"Description of the command.","optional":true,"default":"''","type":[[["StringResolvable"]]]}],"meta":{"line":239,"file":"Command.js","path":"src/struct/commands"}},{"name":"BeforeAction","description":"A function to run before argument parsing and execution.","type":[[["function"]]],"params":[{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]]}],"returns":[[["any"]]],"meta":{"line":269,"file":"Command.js","path":"src/struct/commands"}},{"name":"KeySupplier","description":"A function used to supply the key for the locker.","type":[[["function"]]],"params":[{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]]},{"name":"args","description":"Evaluated arguments.","type":[[["any"]]]}],"returns":[[["string"]]],"meta":{"line":276,"file":"Command.js","path":"src/struct/commands"}},{"name":"ExecutionPredicate","description":"A function used to check if the command should run arbitrarily.","type":[[["function"]]],"params":[{"name":"message","description":"Message to check.","type":[[["Message"]]]}],"returns":[[["boolean"]]],"meta":{"line":284,"file":"Command.js","path":"src/struct/commands"}},{"name":"MissingPermissionSupplier","description":"A function used to check if a message has permissions for the command.\nA non-null return value signifies the reason for missing permissions.","type":[[["function"]]],"params":[{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]]}],"returns":[[["any"]]],"meta":{"line":291,"file":"Command.js","path":"src/struct/commands"}},{"name":"RegexSupplier","description":"A function used to return a regular expression.","type":[[["function"]]],"params":[{"name":"message","description":"Message to get regex for.","type":[[["Message"]]]}],"returns":[[["RegExp"]]],"meta":{"line":299,"file":"Command.js","path":"src/struct/commands"}},{"name":"ArgumentGenerator","description":"Generator for arguments.\nWhen yielding argument options, that argument is ran and the result of the processing is given.\nThe last value when the generator is done is the resulting `args` for the command's `exec`.","type":[[["GeneratorFunction"]]],"params":[{"name":"message","description":"Message that triggered the command.","type":[[["Message"]]]},{"name":"parsed","description":"Parsed content.","type":[[["ContentParserResult"]]]},{"name":"state","description":"Argument processing state.","type":[[["ArgumentRunnerState"]]]}],"returns":[[["IterableIterator","<("],["ArgumentOptions","|"],["Flag",")>"]]],"meta":{"line":306,"file":"Command.js","path":"src/struct/commands"}},{"name":"CommandHandlerOptions","description":"Also includes properties from AkairoHandlerOptions.","type":[[["AkairoHandlerOptions"]]],"props":[{"name":"blockClient","description":"Whether or not to block self.","optional":true,"default":true,"type":[[["boolean"]]]},{"name":"blockBots","description":"Whether or not to block bots.","optional":true,"default":true,"type":[[["boolean"]]]},{"name":"prefix","description":"Default command prefix(es).","optional":true,"default":"'!'","type":[[["string"]],[["Array","<"],["string",">"]],[["PrefixSupplier"]]]},{"name":"allowMention","description":"Whether or not to allow mentions to the client user as a prefix.","optional":true,"default":true,"type":[[["boolean"]],[["MentionPrefixPredicate"]]]},{"name":"aliasReplacement","description":"Regular expression to automatically make command aliases.\nFor example, using `/-/g` would mean that aliases containing `-` would be valid with and without it.\nSo, the alias `command-name` is valid as both `command-name` and `commandname`.","optional":true,"type":[[["RegExp"]]]},{"name":"handleEdits","description":"Whether or not to handle edited messages using CommandUtil.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"storeMessages","description":"Whether or not to have CommandUtil store all prompts and their replies.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"commandUtil","description":"Whether or not to assign `message.util`.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"commandUtilLifetime","description":"Milliseconds a message should exist for before its command util instance is marked for removal.\nIf 0, CommandUtil instances will never be removed and will cause memory to increase indefinitely.","optional":true,"default":"3e5","type":[[["number"]]]},{"name":"commandUtilSweepInterval","description":"Time interval in milliseconds for sweeping command util instances.\nIf 0, CommandUtil instances will never be removed and will cause memory to increase indefinitely.","optional":true,"default":"3e5","type":[[["number"]]]},{"name":"fetchMembers","description":"Whether or not to fetch member on each message from a guild.","optional":true,"default":false,"type":[[["boolean"]]]},{"name":"defaultCooldown","description":"The default cooldown for commands.","optional":true,"default":0,"type":[[["number"]]]},{"name":"ignoreCooldown","description":"ID of user(s) to ignore cooldown or a function to ignore.\nDefaults to the client owner(s).","optional":true,"type":[[["Snowflake"]],[["Array","<"],["Snowflake",">"]],[["IgnoreCheckPredicate"]]]},{"name":"ignorePermissions","description":"ID of user(s) to ignore `userPermissions` checks or a function to ignore.","optional":true,"default":"[]","type":[[["Snowflake"]],[["Array","<"],["Snowflake",">"]],[["IgnoreCheckPredicate"]]]},{"name":"argumentDefaults","description":"The default argument options.","optional":true,"type":[[["DefaultArgumentOptions"]]]}],"meta":{"line":1118,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"CooldownData","description":"Data for managing cooldowns.","type":[[["Object"]]],"props":[{"name":"timer","description":"Timeout object.","type":[[["Timeout"]]]},{"name":"end","description":"When the cooldown ends.","type":[[["number"]]]},{"name":"uses","description":"Number of times the command has been used.","type":[[["number"]]]}],"meta":{"line":1143,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"ParsedComponentData","description":"Various parsed components of the message.","type":[[["Object"]]],"props":[{"name":"command","description":"The command used.","nullable":true,"type":[[["Command"]]]},{"name":"prefix","description":"The prefix used.","nullable":true,"type":[[["string"]]]},{"name":"alias","description":"The alias used.","nullable":true,"type":[[["string"]]]},{"name":"content","description":"The content to the right of the alias.","nullable":true,"type":[[["string"]]]},{"name":"afterPrefix","description":"The content to the right of the prefix.","nullable":true,"type":[[["string"]]]}],"meta":{"line":1151,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"IgnoreCheckPredicate","description":"A function that returns whether this message should be ignored for a certain check.","type":[[["function"]]],"params":[{"name":"message","description":"Message to check.","type":[[["Message"]]]},{"name":"command","description":"Command to check.","type":[[["Command"]]]}],"returns":[[["boolean"]]],"meta":{"line":1161,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"MentionPrefixPredicate","description":"A function that returns whether mentions can be used as a prefix.","type":[[["function"]]],"params":[{"name":"message","description":"Message to option for.","type":[[["Message"]]]}],"returns":[[["boolean"]]],"meta":{"line":1169,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"PrefixSupplier","description":"A function that returns the prefix(es) to use.","type":[[["function"]]],"params":[{"name":"message","description":"Message to get prefix for.","type":[[["Message"]]]}],"returns":[[["string"]],[["Array","<"],["string",">"]]],"meta":{"line":1176,"file":"CommandHandler.js","path":"src/struct/commands"}},{"name":"MessageExtensions","description":"Extra properties applied to the Discord.js message object.","type":[[["Object"]]],"props":[{"name":"util","description":"Utilities for command responding.\nAvailable on all messages after 'all' inhibitors and built-in inhibitors (bot, client).\nNot all properties of the util are available, depending on the input.","nullable":true,"type":[[["CommandUtil"]]]}],"meta":{"line":166,"file":"CommandUtil.js","path":"src/struct/commands"}},{"name":"ContentParserOptions","description":"Options for the content parser.","access":"private","type":[[["Object"]]],"props":[{"name":"flagWords","description":"Words considered flags.","optional":true,"default":"[]","type":[[["Array","<"],["string",">"]]]},{"name":"optionFlagWords","description":"Words considered option flags.","optional":true,"default":"[]","type":[[["Array","<"],["string",">"]]]},{"name":"quoted","description":"Whether to parse quotes.","optional":true,"default":true,"type":[[["boolean"]]]},{"name":"separator","description":"Whether to parse a separator.","optional":true,"type":[[["string"]]]}],"meta":{"line":489,"file":"ContentParser.js","path":"src/struct/commands"}},{"name":"ContentParserResult","description":"Result of parsing.","type":[[["Object"]]],"props":[{"name":"all","description":"All phrases and flags.","type":[[["Array","<"],["StringData",">"]]]},{"name":"phrases","description":"Phrases.","type":[[["Array","<"],["StringData",">"]]]},{"name":"flags","description":"Flags.","type":[[["Array","<"],["StringData",">"]]]},{"name":"optionFlags","description":"Option flags.","type":[[["Array","<"],["StringData",">"]]]}],"meta":{"line":499,"file":"ContentParser.js","path":"src/struct/commands"}},{"name":"ExtractedFlags","description":"Flags extracted from an argument list.","access":"private","type":[[["Object"]]],"props":[{"name":"flagWords","description":"Words considered flags.","optional":true,"default":"[]","type":[[["Array","<"],["string",">"]]]},{"name":"optionFlagWords","description":"Words considered option flags.","optional":true,"default":"[]","type":[[["Array","<"],["string",">"]]]}],"meta":{"line":508,"file":"ContentParser.js","path":"src/struct/commands"}},{"name":"StringData","description":"A single phrase or flag.","type":[[["Object"]]],"props":[{"name":"type","description":"One of 'Phrase', 'Flag', 'OptionFlag'.","type":[[["string"]]]},{"name":"raw","description":"The raw string with whitespace and/or separator.","type":[[["string"]]]},{"name":"key","description":"The key of a 'Flag' or 'OptionFlag'.","nullable":true,"type":[[["string"]]]},{"name":"value","description":"The value of a 'Phrase' or 'OptionFlag'.","nullable":true,"type":[[["string"]]]}],"meta":{"line":516,"file":"ContentParser.js","path":"src/struct/commands"}},{"name":"InhibitorOptions","description":"Options to use for inhibitor execution behavior.\nAlso includes properties from AkairoModuleOptions.","type":[[["AkairoModuleOptions"]]],"props":[{"name":"reason","description":"Reason emitted when command or message is blocked.","optional":true,"default":"''","type":[[["string"]]]},{"name":"type","description":"Can be 'all' to run on all messages, 'pre' to run on messages not blocked by the built-in inhibitors, or 'post' to run on messages that are commands.","optional":true,"default":"'post'","type":[[["boolean"]]]},{"name":"priority","description":"Priority for the inhibitor for when more than one inhibitors block a message.\nThe inhibitor with the highest priority is the one that is used for the block reason.","optional":true,"default":0,"type":[[["number"]]]}],"meta":{"line":80,"file":"Inhibitor.js","path":"src/struct/inhibitors"}},{"name":"ListenerOptions","description":"Options to use for listener execution behavior.\nAlso includes properties from AkairoModuleOptions.","type":[[["AkairoModuleOptions"]]],"props":[{"name":"emitter","description":"The event emitter, either a key from `ListenerHandler#emitters` or an EventEmitter.","type":[[["string"]],[["EventEmitter"]]]},{"name":"event","description":"Event name to listen to.","type":[[["string"]]]},{"name":"type","description":"Type of listener, either 'on' or 'once'.","optional":true,"default":"'on'","type":[[["string"]]]}],"meta":{"line":77,"file":"Listener.js","path":"src/struct/listeners"}}],"externals":[]}