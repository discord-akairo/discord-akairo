<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Tutorial: 11. Advanced Args and Prompts - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AkairoClient.html">AkairoClient</a></li><li><a href="AkairoHandler.html">AkairoHandler</a></li><li><a href="AkairoModule.html">AkairoModule</a></li><li><a href="Argument.html">Argument</a></li><li><a href="Category.html">Category</a></li><li><a href="ClientUtil.html">ClientUtil</a></li><li><a href="Command.html">Command</a></li><li><a href="CommandHandler.html">CommandHandler</a></li><li><a href="CommandUtil.html">CommandUtil</a></li><li><a href="Inhibitor.html">Inhibitor</a></li><li><a href="InhibitorHandler.html">InhibitorHandler</a></li><li><a href="Listener.html">Listener</a></li><li><a href="ListenerHandler.html">ListenerHandler</a></li><li><a href="SQLiteHandler.html">SQLiteHandler</a></li><li><a href="TypeResolver.html">TypeResolver</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-1. Setting Up a Bot.html">1. Setting Up a Bot</a></li><li><a href="tutorial-2. Creating a Command.html">2. Creating a Command</a></li><li><a href="tutorial-3. Customizing Commands.html">3. Customizing Commands</a></li><li><a href="tutorial-4. Creating an Inhibitor.html">4. Creating an Inhibitor</a></li><li><a href="tutorial-5. Creating a Listener.html">5. Creating a Listener</a></li><li><a href="tutorial-6. Storing Data with SQLite.html">6. Storing Data with SQLite</a></li><li><a href="tutorial-7. Regex and Conditionals.html">7. Regex and Conditionals</a></li><li><a href="tutorial-8. Argument Prompting.html">8. Argument Prompting</a></li><li><a href="tutorial-9. Handling Edits.html">9. Handling Edits</a></li><li><a href="tutorial-10. Customizing Types.html">10. Customizing Types</a></li><li><a href="tutorial-11. Advanced Args and Prompts.html">11. Advanced Args and Prompts</a></li><li><a href="tutorial-12. Other Things.html">12. Other Things</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<div id="main">
    
    <h1 class="page-title">Tutorial: 11. Advanced Args and Prompts</h1>
    

    <section>

<article>
    <p>This tutorial is to show how arguments can be based on previous arguments.<br>It also shows off the ways you can customize prompts and prompt messages.  </p>
<p>In this tutorial, a command will be made that:</p>
<ol>
<li>Ask the user for a guild member.</li>
<li>Ask the user to narrow down to one member from the possibilties.</li>
<li>Ask the user for as many texts as they want.</li>
<li>Send that member the list of texts.</li>
</ol>
<h2>Arguments Setup</h2><p>First, let's setup the command and arguments.</p>
<pre class="prettyprint source lang-js"><code>const { Command } = require('discord-akairo');

function exec(message, args) {
    // Fun stuff!
}

module.exports = new Command('spam', exec, {
    aliases: ['spam'],
    args: [
        {
            id: 'members'
        },
        {
            id: 'member'
        },
        {
            id: 'texts'
        }
    ]
});</code></pre><p>The three arguments here are:</p>
<ul>
<li>The collection of members to narrow down, <code>members</code>.</li>
<li>The narrowed-down member, <code>member</code>.</li>
<li>The list of texts, <code>texts</code>.</li>
</ul>
<p>The first argument is fairly simple.</p>
<pre class="prettyprint source lang-js"><code>{
    id: 'members',
    type: 'members',
    prompt: {
        start: 'Who would you like to send to?',
        retry: 'Please input a valid member!'
    }
}</code></pre><p>The second argument requires a bit of tinkering.<br>A custom type function will be used.  </p>
<pre class="prettyprint source lang-js"><code>{
    id: 'member',
    match: 'none',
    type: function type(word, message, args) {
        if (args.members.size === 1) return args.members.first();
        if (!word) return null;

        const members = this.client.util.resolveMembers(word, args.members);
        if (members.size === 1) return members.first();
        if (!members.size) return null;

        args.members = members;
        return null;
    },
    prompt: {
        start: (message, args) => {
            return [
                `${message.author}, multiple people were found, who would you like?`,
                args.members.map(members => members.user.longName).join(', ')
            ];
        },
        retry: (message, args) => {
            return [
                `${message.author}, multiple people were found again, who would you like?`,
                args.members.map(members => members.user.longName).join(', ')
            ];
        }
    }
}</code></pre><p>The <code>none</code> match matches nothing, since we only want to prompt, not match anything.  </p>
<p>In the type function, this happens:  </p>
<ol>
<li><p>Check if the first arg has a size of one.<br>This means only one member was found.<br>So, we can resolve with that member and not worry about prompting.</p>
</li>
<li><p>Check if word is empty.<br>Since it is a none match, this will always be true the first time.<br>This causes it to skip to the prompt since <code>null</code> is returned.</p>
</li>
<li><p>Resolve members using input from the prompt.</p>
</li>
<li><p>Check if size is one, just like in step 1.</p>
</li>
<li><p>If no members were found, return <code>null</code> to prompt again with the collection from before.</p>
</li>
<li><p>Set the old <code>members</code> args to the newly resolved collection of members.</p>
</li>
<li><p>Return <code>null</code> to prompt and repeat the process.</p>
</li>
</ol>
<p>And now, we can move on to the third a fairly simple argument.</p>
<pre class="prettyprint source lang-js"><code>{
    id: 'texts',
    match: 'none',
    prompt: {
        start: 'What texts would you like to send?',
        infinite: true
    }
}</code></pre><p>The <code>infinite</code> prompt option is used here.<br>This means that the prompt will not end until the user says so.<br>They can end the prompt by using the <code>stopWord</code>, which by default is &quot;stop&quot;.  </p>
<p>We also match <code>none</code> here to make sure nothing from the user ends up in here accidentally.<br>This argument will end up as an array of inputs.  </p>
<p>Now, we can do the rest of our command:  </p>
<pre class="prettyprint source lang-js"><code>const { Command } = require('discord-akairo');

function exec(message, args) {
    // That was simple.
    return args.member.send(args.texts.join('\n'));
}

module.exports = new Command('send', exec, {
    aliases: ['send'],
    args: [
        {
            id: 'members',
            type: 'members',
            prompt: {
                start: 'Who would you like to send to?',
                retry: 'Please input a valid member!'
            }
        },
        {
            id: 'member',
            match: 'none',
            type: function type(word, message, args) {
                if (args.members.size === 1) return args.members.first();
                if (!word) return null;

                const members = this.client.util.resolveMembers(word, args.members);
                if (members.size === 1) return members.first();
                if (!members.size) return null;

                args.members = members;
                return null;
            },
            prompt: {
                start: (message, args) => {
                    return [
                        `${message.author}, multiple people were found, who would you like?`,
                        args.members.map(members => members.user.longName).join(', ')
                    ];
                },
                retry: (message, args) => {
                    return [
                        `${message.author}, multiple people were found again, who would you like?`,
                        args.members.map(members => members.user.longName).join(', ')
                    ];
                }
            }
        },
        {
            id: 'texts',
            match: 'none',
            prompt: {
                start: 'What texts would you like to send?',
                infinite: true
            }
        }
    ]
});</code></pre><p>That is all for now!<br>Enjoy making really fun and complex commands!  </p>
</article>

</section>

</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>